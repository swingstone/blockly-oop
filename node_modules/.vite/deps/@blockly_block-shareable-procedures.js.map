{
  "version": 3,
  "sources": ["../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/webpack/universalModuleDefinition", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/webpack/bootstrap", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/webpack/runtime/define property getters", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/webpack/runtime/hasOwnProperty shorthand", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/webpack/runtime/make namespace object", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_base.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_parameter_base.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_parameter_rename.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/update_procedures.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/observable_parameter_model.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_change_return.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_create.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_delete.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_enable.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_parameter_create.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_parameter_delete.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/events_procedure_rename.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/observable_procedure_model.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/blocks.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/i_procedure_block.ts", "../../@blockly/block-shareable-procedures/dist/webpack:/@blockly/block-shareable-procedures/src/index.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__573__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The base event for an event associated with a procedure.\n */\nexport abstract class ProcedureBase extends Blockly.Events.Abstract {\n  static readonly TYPE: string = 'procedure_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureBase.TYPE;\n\n  isBlank = false;\n\n  /**\n   * Constructs the base procedure event.\n   *\n   * @param workspace The workspace the procedure model exists in.\n   * @param procedure The procedure model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    readonly procedure: Blockly.procedures.IProcedureModel,\n  ) {\n    super();\n    this.workspaceId = workspace.id;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureBaseJson {\n    const json = super.toJson() as ProcedureBaseJson;\n    json['procedureId'] = this.procedure.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureBaseJson extends Blockly.Events.AbstractEventJson {\n  procedureId: string;\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * The base event for an event associated with a procedure parameter.\n */\nexport abstract class ProcedureParameterBase extends ProcedureBase {\n  static readonly TYPE: string = 'procedure_parameter_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterBase.TYPE;\n\n  /**\n   * Constructs the procedure parameter base event.\n   *\n   * @param workspace The workspace the parameter model exists in.\n   * @param procedure The procedure model the parameter model belongs to.\n   * @param parameter The parameter model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly parameter: Blockly.procedures.IParameterModel,\n  ) {\n    super(workspace, procedure);\n    this.recordUndo = false;\n  }\n\n  /**\n   * Finds the parameter with the given ID in the procedure model with the given\n   * ID, if both things exist.\n   *\n   * @param workspace The workspace to search for the parameter.\n   * @param procedureId The ID of the procedure model to search for\n   *     the parameter.\n   * @param paramId The ID of the parameter to search for.\n   * @returns The parameter model that was found.\n   * @internal\n   */\n  static findMatchingParameter(\n    workspace: Blockly.Workspace,\n    procedureId: string,\n    paramId: string,\n  ): ProcedureParameterPair {\n    const procedure = workspace.getProcedureMap().get(procedureId);\n    if (!procedure) return {procedure: undefined, parameter: undefined};\n    const parameter = procedure\n      .getParameters()\n      .find((p) => p.getId() === paramId);\n    if (!parameter) return {procedure, parameter: undefined};\n    return {procedure, parameter};\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterBaseJson {\n    const json = super.toJson() as ProcedureParameterBaseJson;\n    json['parameterId'] = this.parameter.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureParameterPair {\n  procedure?: Blockly.procedures.IProcedureModel;\n  parameter?: Blockly.procedures.IParameterModel;\n}\n\nexport interface ProcedureParameterBaseJson extends ProcedureBaseJson {\n  parameterId: string;\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a procedure parameter was renamed.\n */\nexport class ProcedureParameterRename extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterRename.TYPE;\n\n  /** The new name of the procedure parameter. */\n  private readonly newName: string;\n\n  /** The new ID the backing variable for the parameter. */\n  private readonly newVarId: string;\n\n  /**\n   * Constructs the procedure parameter rename event.\n   *\n   * @param workspace The workpace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model this event is associated with.\n   * @param oldName The old name of the procedure parameter.\n   * @param newName The (optional) new name of the procedure parameter. If not\n   *     provided, the parameter model will be inspected to see what its current\n   *     name is.\n   * @param newVarId The (optional) new id of the procedure parameter's backing\n   *     variable. If not provided, the parameter model will be inspected to\n   *     see what its current name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly oldName: string,\n    newName?: string,\n    newVarId?: string,\n  ) {\n    super(workspace, procedure, parameter);\n\n    this.newName = newName ?? parameter.getName();\n    this.newVarId = newVarId ?? parameter.getVariableModel().getId();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const {parameter} = ProcedureParameterBase.findMatchingParameter(\n      this.getEventWorkspace_(),\n      this.procedure.getId(),\n      this.parameter.getId(),\n    );\n    if (forward) {\n      if (parameter.getName() !== this.oldName) return;\n      (parameter as ObservableParameterModel).setName(\n        this.newName,\n        this.newVarId,\n      );\n    } else {\n      if (parameter.getName() !== this.newName) return;\n      parameter.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterRenameJson {\n    const json = super.toJson() as ProcedureParameterRenameJson;\n    json['newName'] = this.newName;\n    json['newVarId'] = this.newVarId;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterRename {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterRename(\n      workspace,\n      procedure,\n      parameter as ObservableParameterModel,\n      json['oldName'],\n      json['newName'],\n      json['newVarId'],\n    );\n  }\n}\n\nexport interface ProcedureParameterRenameJson\n  extends ProcedureParameterBaseJson {\n  oldName: string;\n  newName: string;\n  newVarId: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterRename.TYPE,\n  ProcedureParameterRename,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Calls the `doProcedureUpdate` method on all blocks which implement it.\n *\n * @param workspace The workspace within which to trigger block updates.\n * @internal\n */\nexport function triggerProceduresUpdate(workspace: Blockly.Workspace) {\n  if (workspace.isClearing) return;\n  for (const block of workspace.getAllBlocks(false)) {\n    if (Blockly.procedures.isProcedureBlock(block)) {\n      block.doProcedureUpdate();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureParameterRename} from './events_procedure_parameter_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure parameter. */\nexport class ObservableParameterModel\n  implements Blockly.procedures.IParameterModel\n{\n  private id: string;\n  private variable: Blockly.VariableModel;\n  private shouldFireEvents = false;\n  private procedureModel: Blockly.procedures.IProcedureModel | null = null;\n\n  /**\n   * Constructor for the procedure parameter.\n   *\n   * @param workspace The workspace this parameter model exists in.\n   * @param name The name of this parameter.\n   * @param id The optional unique language-neutral ID of the parameter.\n   * @param varId The optional ID of the variable this parameter should be\n   *     associated with.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n    varId?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.variable = this.createBackingVariable(name, varId);\n  }\n\n  /**\n   * Sets the name of this parameter to the given name.\n   *\n   * @param name The string to set the name to.\n   * @param id The optional ID the backing variable should have.\n   * @returns This parameter model.\n   */\n  setName(name: string, id?: string): this {\n    if (name === this.variable.name) return this;\n    const oldName = this.variable.name;\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', id);\n    triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterRename(\n          this.workspace,\n          this.procedureModel,\n          this,\n          oldName,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Creates a backing variable in a way that is subclassable.\n   *\n   * @param name The string to set set the variable to.\n   * @param varId The optional ID the backing variable should have.\n   * @returns The created variable model.\n   */\n  protected createBackingVariable(\n    name: string,\n    varId?: string,\n  ): Blockly.VariableModel {\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', varId);\n    return this.variable;\n  }\n\n  /**\n   * Unimplemented. The built-in ParameterModel does not support typing.\n   * If you want your procedure blocks to have typed parameters, you need to\n   * implement your own ParameterModel.\n   *\n   * @param types The types to set this parameter to.\n   * @throws Throws for the ObservableParameterModel specifically because this\n   *     method is unimplemented.\n   */\n  setTypes(types: string[]): this {\n    throw new Error(\n      'The built-in ParameterModel does not support typing. You need to ' +\n        'implement your own custom ParameterModel.',\n    );\n  }\n\n  /**\n   * @returns the name of this parameter.\n   */\n  getName(): string {\n    return this.variable.name;\n  }\n\n  /**\n   * @returns the types of this parameter.\n   */\n  getTypes(): string[] {\n    return [];\n  }\n\n  /**\n   * Returns the unique language-neutral ID for the parameter. This represents\n   * the identity of the variable model which does not change over time.\n   *\n   * @returns The unique language-neutral ID for the parameter.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns the variable model associated with the parameter model.\n   */\n  getVariableModel(): Blockly.VariableModel {\n    return this.variable;\n  }\n\n  /**\n   * Tells the parameter model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n  }\n\n  /**\n   * Tells the parameter model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    this.shouldFireEvents = false;\n  }\n\n  /**\n   * Sets the procedure model this parameter is a part of.\n   *\n   * @param model The procedure model this parameter is a part of.\n   * @returns This parameter model.\n   */\n  setProcedureModel(model: Blockly.procedures.IProcedureModel): this {\n    this.procedureModel = model;\n    return this;\n  }\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure's return type/status has changed.\n */\nexport class ProcedureChangeReturn extends ProcedureBase {\n  static readonly TYPE = 'procedure_change';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureChangeReturn.TYPE;\n\n  /** The new type(s) the procedure's return has been set to. */\n  private newTypes: string[] | null;\n\n  /**\n   * Constructs the procedure change event.\n   *\n   * @param workpace The workspace this change event is associated with.\n   * @param procedure The model this change event is associated with.\n   * @param oldTypes The type(s) the procedure's return was set to before it\n   *     changed.\n   */\n  constructor(\n    workpace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldTypes: string[] | null,\n  ) {\n    super(workpace, procedure);\n\n    this.newTypes = procedure.getReturnTypes();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setReturnTypes(this.newTypes);\n    } else {\n      procedureModel.setReturnTypes(this.oldTypes);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureChangeReturnJson {\n    const json = super.toJson() as ProcedureChangeReturnJson;\n    json['oldTypes'] = this.oldTypes;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure change event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure change return event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureChangeReturnJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureChangeReturn {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure change return event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureChangeReturn(workspace, model, json['oldTypes']);\n  }\n}\n\nexport interface ProcedureChangeReturnJson extends ProcedureBaseJson {\n  oldTypes: string[] | null;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureChangeReturn.TYPE,\n  ProcedureChangeReturn,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\n/**\n * Notifies listeners that a procedure data model has been created.\n */\nexport class ProcedureCreate extends ProcedureBase {\n  static readonly TYPE = 'procedure_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureCreate.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    } else {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureCreateJson {\n    const json = super.toJson() as ProcedureCreateJson;\n    json['procedure'] = Blockly.serialization.procedures.saveProcedure(\n      this.procedure,\n    );\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureCreate {\n    return new ProcedureCreate(\n      workspace,\n      Blockly.serialization.procedures.loadProcedure(\n        ObservableProcedureModel,\n        ObservableParameterModel,\n        json['procedure'],\n        workspace,\n      ),\n    );\n  }\n}\n\nexport interface ProcedureCreateJson extends ProcedureBaseJson {\n  procedure: Blockly.serialization.procedures.State;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureCreate.TYPE,\n  ProcedureCreate,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure data model has been deleted.\n */\nexport class ProcedureDelete extends ProcedureBase {\n  static readonly TYPE = 'procedure_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureDelete.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    } else {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureDeleteJson {\n    return super.toJson() as ProcedureDeleteJson;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureDelete {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure delete event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureDelete(workspace, model);\n  }\n}\n\nexport type ProcedureDeleteJson = ProcedureBaseJson;\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureDelete.TYPE,\n  ProcedureDelete,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that the procedure data model has been enabled or\n * disabled.\n */\nexport class ProcedureEnable extends ProcedureBase {\n  static readonly TYPE = 'procedure_enable';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureEnable.TYPE;\n\n  private oldState: boolean;\n  private newState: boolean;\n\n  /**\n   * Constructs the procedure enable event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param newState The (optional) new enabled state of the procedure model.\n   *     If not provided, the procedure model will be inspected to determine\n   *     its current state.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    newState?: boolean,\n  ) {\n    super(workspace, procedure);\n\n    if (newState === undefined) {\n      this.oldState = !procedure.getEnabled();\n      this.newState = procedure.getEnabled();\n    } else {\n      this.oldState = !newState;\n      this.newState = newState;\n    }\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the enabled state of a procedure that does not ' +\n          'exist in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setEnabled(this.newState);\n    } else {\n      procedureModel.setEnabled(this.oldState);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureEnableJson {\n    const json = super.toJson() as ProcedureEnableJson;\n    json['newState'] = this.newState;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure enable event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure enable event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureEnableJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureEnable {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure enable event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureEnable(workspace, model, json['newState']);\n  }\n}\n\nexport interface ProcedureEnableJson extends ProcedureBaseJson {\n  newState: boolean;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureEnable.TYPE,\n  ProcedureEnable,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a parameter has been added to a procedure model.\n */\nexport class ProcedureParameterCreate extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterCreate.TYPE;\n\n  parameter: ObservableParameterModel;\n\n  /**\n   * Constructs the procedure parameter create event.js.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just added to the procedure.\n   * @param index The index the parameter was inserted at.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.insertParameter(this.parameter, this.index);\n    } else {\n      procedureModel.deleteParameter(this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterCreateJson {\n    const json = super.toJson() as ProcedureParameterCreateJson;\n    json['name'] = this.parameter.getName();\n    json['id'] = this.parameter.getId();\n    json['varId'] = this.parameter.getVariableModel().getId();\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterCreate {\n    const procedure = workspace.getProcedureMap().get(json['procedureId']);\n    if (!procedure) {\n      throw new Error(\n        'Cannot deserialize parameter create event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureParameterCreate(\n      workspace,\n      procedure,\n      new ObservableParameterModel(\n        workspace,\n        json['name'],\n        json['id'],\n        json['varId'],\n      ),\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterCreateJson\n  extends ProcedureParameterBaseJson {\n  parameter: Blockly.serialization.procedures.ParameterState;\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterCreate.TYPE,\n  ProcedureParameterCreate,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\n\n/**\n * Notifies listeners that a parameter has been removed from a procedure.\n */\nexport class ProcedureParameterDelete extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterDelete.TYPE;\n\n  /**\n   * Constructs the procedure parameter delete event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just removed from the\n   *     procedure.\n   * @param index The index the parameter was at before it was removed.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: Blockly.procedures.IParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.deleteParameter(this.index);\n    } else {\n      procedureModel.insertParameter(this.parameter, this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterDeleteJson {\n    const json = super.toJson() as ProcedureParameterDeleteJson;\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterDelete {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterDelete(\n      workspace,\n      procedure,\n      parameter,\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterDeleteJson\n  extends ProcedureParameterBaseJson {\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterDelete.TYPE,\n  ProcedureParameterDelete,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/** Notifies listeners that a procedure model has been renamed. */\nexport class ProcedureRename extends ProcedureBase {\n  static readonly TYPE = 'procedure_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureRename.TYPE;\n\n  private newName: string;\n\n  /**\n   * Constructs the procedure rename event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param oldName The old name of the procedure model.\n   * @param newName The (optional) new name of the procedure. If not provided,\n   *     the procedure model will be inspected to see what its current\n   *     name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldName: string,\n    newName?: string,\n  ) {\n    super(workspace, procedure);\n\n    this.newName = newName ?? procedure.getName();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      if (procedureModel.getName() !== this.oldName) return;\n      procedureModel.setName(this.newName);\n    } else {\n      if (procedureModel.getName() !== this.newName) return;\n      procedureModel.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureRenameJson {\n    const json = super.toJson() as ProcedureRenameJson;\n    json['newName'] = this.newName;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureRename {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure rename event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureRename(\n      workspace,\n      model,\n      json['oldName'],\n      json['newName'],\n    );\n  }\n}\n\nexport interface ProcedureRenameJson extends ProcedureBaseJson {\n  oldName: string;\n  newName: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureRename.TYPE,\n  ProcedureRename,\n);\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ProcedureChangeReturn} from './events_procedure_change_return';\nimport {ProcedureCreate} from './events_procedure_create';\nimport {ProcedureDelete} from './events_procedure_delete';\nimport {ProcedureEnable} from './events_procedure_enable';\nimport {ProcedureParameterCreate} from './events_procedure_parameter_create';\nimport {ProcedureParameterDelete} from './events_procedure_parameter_delete';\nimport {ProcedureRename} from './events_procedure_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure signature. */\nexport class ObservableProcedureModel\n  implements Blockly.procedures.IProcedureModel\n{\n  private id: string;\n  private name: string;\n  private parameters: ObservableParameterModel[] = [];\n  private returnTypes: string[] | null = null;\n  private enabled = true;\n  private shouldFireEvents = false;\n  private shouldTriggerUpdates = true;\n\n  /**\n   * Constructor for the procedure model.\n   *\n   * @param workspace The workspace the procedure model is associated with.\n   * @param name The name of the new procedure.\n   * @param id The (optional) unique language-neutral ID for the procedure.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.name = name;\n  }\n\n  /**\n   * Sets the human-readable name of the procedure.\n   *\n   * @param name The human-readable name of the procedure.\n   * @returns This procedure model.\n   */\n  setName(name: string): this {\n    if (name === this.name) return this;\n    const oldName = this.name;\n    this.name = name;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureRename(this.workspace, this, oldName));\n    }\n    return this;\n  }\n\n  /**\n   * Inserts a parameter into the list of parameters.\n   * To move a parameter, first delete it, and then re-insert.\n   *\n   * @param parameterModel The parameter model to insert.\n   * @param index The index to insert it at.\n   * @returns This procedure model.\n   */\n  insertParameter(\n    parameterModel: ObservableParameterModel,\n    index: number,\n  ): this {\n    if (\n      this.parameters[index] &&\n      this.parameters[index].getId() === parameterModel.getId()\n    ) {\n      return this;\n    }\n\n    this.parameters.splice(index, 0, parameterModel);\n    parameterModel.setProcedureModel(this);\n    if (Blockly.isObservable(parameterModel)) {\n      if (this.shouldFireEvents) {\n        parameterModel.startPublishing();\n      } else {\n        parameterModel.stopPublishing();\n      }\n    }\n\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterCreate(\n          this.workspace,\n          this,\n          parameterModel,\n          index,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Removes the parameter at the given index from the parameter list.\n   *\n   * @param index The index of the parameter to remove.\n   * @returns This procedure model.\n   */\n  deleteParameter(index: number): this {\n    if (!this.parameters[index]) return this;\n    const oldParam = this.parameters[index];\n\n    this.parameters.splice(index, 1);\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (Blockly.isObservable(oldParam)) {\n      oldParam.stopPublishing();\n    }\n\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterDelete(this.workspace, this, oldParam, index),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether the procedure has a return value (empty array) or no return\n   * value (null).\n   * This procedure model does not support procedures that have actual\n   * return types (i.e. non-empty arrays, e.g. ['number']).\n   *\n   * @param types Used to set whether this procedure has a return value\n   *     (empty array) or no return value (null).\n   * @returns This procedure model.\n   */\n  setReturnTypes(types: string[] | null): this {\n    if (types && types.length) {\n      throw new Error(\n        'The built-in ProcedureModel does not support typing. You need to ' +\n          'implement your own custom ProcedureModel.',\n      );\n    }\n    // Either they're both an empty array, or both null. Noop either way.\n    if (!!types === !!this.returnTypes) return this;\n    const oldReturnTypes = this.returnTypes;\n    this.returnTypes = types;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureChangeReturn(this.workspace, this, oldReturnTypes),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether this procedure is enabled/disabled. If a procedure is disabled\n   * all procedure caller blocks should be disabled as well.\n   *\n   * @param enabled Whether this procedure is enabled/disabled.\n   * @returns This procedure model.\n   */\n  setEnabled(enabled: boolean): this {\n    if (enabled === this.enabled) return this;\n    this.enabled = enabled;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureEnable(this.workspace, this));\n    }\n    return this;\n  }\n\n  /**\n   * Disables triggering updates to procedure blocks until the endBulkUpdate\n   * is called.\n   *\n   * @internal\n   */\n  startBulkUpdate() {\n    this.shouldTriggerUpdates = false;\n  }\n\n  /**\n   * Triggers an update to procedure blocks. Should be used with\n   * startBulkUpdate.\n   *\n   * @internal\n   */\n  endBulkUpdate() {\n    this.shouldTriggerUpdates = true;\n    triggerProceduresUpdate(this.workspace);\n  }\n\n  /**\n   * @returns The unique language-neutral ID for the procedure.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns The human-readable name of the procedure\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * @param index The index of the parameter to return.\n   * @returns the parameter at the given index in the parameter list.\n   */\n  getParameter(index: number): Blockly.procedures.IParameterModel {\n    return this.parameters[index];\n  }\n\n  /**\n   * @returns an array of all of the parameters in the parameter list.\n   */\n  getParameters(): Blockly.procedures.IParameterModel[] {\n    return [...this.parameters];\n  }\n\n  /**\n   * Returns the return type of the procedure.\n   * Null represents a procedure that does not return a value.\n   *\n   * @returns the return type of the procedure.\n   */\n  getReturnTypes(): string[] | null {\n    return this.returnTypes;\n  }\n\n  /**\n   * Returns whether the procedure is enabled/disabled. If a procedure is\n   * disabled, all procedure caller blocks should be disabled as well.\n   *\n   * @returns Returns whether the procedure is enabled/disabled.\n   */\n  getEnabled(): boolean {\n    return this.enabled;\n  }\n\n  /**\n   * Tells the procedure model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n    Blockly.Events.fire(new ProcedureCreate(this.workspace, this));\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.startPublishing();\n    }\n  }\n\n  /**\n   * Tells the procedure model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    triggerProceduresUpdate(this.workspace);\n    Blockly.Events.fire(new ProcedureDelete(this.workspace, this));\n    this.shouldFireEvents = false;\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.stopPublishing();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableProcedureModel} from './observable_procedure_model';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {IProcedureBlock} from './i_procedure_block';\nimport {ProcedureCreate} from './events_procedure_create';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A dictionary of the block definitions provided by this module.\n *\n * @type {!Object<string, Object>}\n */\nexport const blocks = Blockly.common.createBlockDefinitionsFromJsonArray([\n  {\n    type: 'procedures_defnoreturn',\n    message0: '%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFNORETURN_DO} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFNORETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defnoreturn_get_caller_block_mixin',\n      'procedure_defnoreturn_set_comment_helper',\n      'procedure_def_set_no_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callnoreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    nextStatement: null,\n    previousStatement: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLNORETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callernoreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n  {\n    type: 'procedures_defreturn',\n    message0: '%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFRETURN_DO} %1',\n    message2: '%{BKY_PROCEDURES_DEFRETURN_RETURN} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    args2: [\n      {\n        type: 'input_value',\n        align: 'right',\n        name: 'RETURN',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFRETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defreturn_get_caller_block_mixin',\n      'procedure_defreturn_set_comment_helper',\n      'procedure_def_set_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    output: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLRETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callerreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n]);\n\nconst procedureDefGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    /**\n     * Returns the data model for this procedure block.\n     *\n     * @returns The data model for this procedure\n     *     block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns True because this is a procedure definition block.\n     */\n    isProcedureDef() {\n      return true;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n\n    /**\n     * Disposes of the data model for this procedure block when the block is\n     * disposed.\n     */\n    destroy: function () {\n      this.workspace.getProcedureMap().delete(this.getProcedureModel().getId());\n    },\n  };\n\n  mixin.model_ = new ObservableProcedureModel(\n    this.workspace,\n    Blockly.Procedures.findLegalName(this.getFieldValue('NAME'), this),\n  );\n\n  // Events cannot be fired from instantiation when deserializing or dragging\n  // from the flyout. So make this consistent and never fire from instantiation.\n  Blockly.Events.disable();\n  this.workspace.getProcedureMap().add(mixin.getProcedureModel());\n  Blockly.Events.enable();\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_def_get_def_mixin',\n  procedureDefGetDefMixin,\n);\n\nconst procedureDefVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming.\n     * If the ID matches one of this block's variables, rename it.\n     *\n     * @param oldId ID of variable to rename.\n     * @param newId ID of new variable.  May be the same as oldId, but\n     *     with an updated name.  Guaranteed to be the same type as the old\n     *     variable.\n     * @override\n     * @this {Blockly.Block}\n     */\n    renameVarById: function (oldId, newId) {\n      const oldVar = this.workspace.getVariableById(oldId);\n      const model = this.getProcedureModel();\n      const index = model\n        .getParameters()\n        .findIndex((p) => p.getVariableModel() === oldVar);\n      if (index === -1) return; // Not found.\n      const newVar = this.workspace.getVariableById(newId);\n      const oldParam = model.getParameter(index);\n      oldParam.setName(newVar.name);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register('procedure_def_var_mixin', procedureDefVarMixin);\n\nconst procedureDefUpdateShapeMixin = {\n  /**\n   * Updates the block to reflect the state of the procedure model.\n   */\n  doProcedureUpdate: function () {\n    this.setFieldValue(this.getProcedureModel().getName(), 'NAME');\n    this.setEnabled(this.getProcedureModel().getEnabled());\n    this.updateParameters_();\n    this.updateMutator_();\n  },\n\n  /**\n   * Updates the parameters field to reflect the parameters in the procedure\n   * model.\n   */\n  updateParameters_: function () {\n    const params = this.getProcedureModel()\n      .getParameters()\n      .map((p) => p.getName());\n    const paramString = params.length\n      ? `${Blockly.Msg['PROCEDURES_BEFORE_PARAMS']} ${params.join(', ')}`\n      : '';\n\n    // The field is deterministic based on other events, no need to fire.\n    Blockly.Events.disable();\n    try {\n      this.setFieldValue(paramString, 'PARAMS');\n    } finally {\n      Blockly.Events.enable();\n    }\n  },\n\n  /**\n   * Updates the parameter blocks in the mutator (if it is open) to reflect\n   * the state of the procedure model.\n   */\n  updateMutator_: function () {\n    const mutator = this.getIcon(Blockly.icons.MutatorIcon.TYPE);\n    if (!mutator?.bubbleIsVisible()) return;\n\n    const mutatorWorkspace = this.mutator.getWorkspace();\n    for (const p of this.getProcedureModel().getParameters()) {\n      const block = mutatorWorkspace.getBlockById(p.getId());\n      if (!block) continue; // Should not happen.\n      if (block.getFieldValue('NAME') !== p.getName()) {\n        block.setFieldValue(p.getName(), 'NAME');\n      }\n    }\n  },\n\n  /**\n   * Add or remove the statement block from this function definition.\n   *\n   * @param hasStatements True if a statement block is needed.\n   * @this {Blockly.Block}\n   */\n  setStatements_: function (hasStatements) {\n    if (this.hasStatements_ === hasStatements) {\n      return;\n    }\n    if (hasStatements) {\n      this.appendStatementInput('STACK').appendField(\n        Blockly.Msg['PROCEDURES_DEFNORETURN_DO'],\n      );\n      if (this.getInput('RETURN')) {\n        this.moveInputBefore('STACK', 'RETURN');\n      }\n      // Restore the stack, if one was saved.\n      this.statementConnection_?.(this, 'STACK');\n      this.statementConnection_ = null;\n    } else {\n      // Save the stack, then disconnect it.\n      const stackConnection = this.getInput('STACK').connection;\n      this.statementConnection_ = stackConnection.targetConnection;\n      if (this.statementConnection_) {\n        const stackBlock = stackConnection.targetBlock();\n        stackBlock.unplug();\n        stackBlock.bumpNeighbours();\n      }\n      this.removeInput('STACK', true);\n    }\n    this.hasStatements_ = hasStatements;\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_update_shape_mixin',\n  procedureDefUpdateShapeMixin,\n);\n\nconst procedureDefValidatorHelper = function () {\n  const nameField = this.getField('NAME');\n  nameField.setValue(Blockly.Procedures.findLegalName('', this));\n  nameField.setValidator(Blockly.Procedures.rename);\n};\nBlockly.Extensions.register(\n  'procedure_def_validator_helper',\n  procedureDefValidatorHelper,\n);\n\nconst procedureDefMutator = {\n  hasStatements_: true,\n\n  /**\n   * Create XML to represent the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const params = this.getProcedureModel().getParameters();\n    for (let i = 0; i < params.length; i++) {\n      const parameter = Blockly.utils.xml.createElement('arg');\n      const varModel = params[i].getVariableModel();\n      parameter.setAttribute('name', varModel.name);\n      parameter.setAttribute('varid', varModel.getId());\n      container.appendChild(parameter);\n    }\n\n    // Save whether the statement input is visible.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    for (let i = 0; i < xmlElement.childNodes.length; i++) {\n      const node = xmlElement.childNodes[i];\n      if (node.nodeName.toLowerCase() !== 'arg') continue;\n      const varId = node.getAttribute('varid');\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(\n          this.workspace,\n          node.getAttribute('name'),\n          undefined,\n          varId,\n        ),\n        i,\n      );\n    }\n    this.setStatements_(xmlElement.getAttribute('statements') !== 'false');\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @param doFullSerialization Tells the block if it should serialize\n   *     its entire state (including data stored in the backing procedure\n   *     model). Used for copy-paste.\n   * @returns The state of this block, eg the parameters and statements.\n   */\n  saveExtraState: function (doFullSerialization) {\n    const state = Object.create(null);\n    state['procedureId'] = this.getProcedureModel().getId();\n\n    if (doFullSerialization) {\n      state['fullSerialization'] = true;\n      const params = this.getProcedureModel().getParameters();\n      if (params.length) {\n        state['params'] = params.map((p) => {\n          return {\n            name: p.getName(),\n            id: p.getVariableModel().getId(),\n            // Ideally this would be id, and the other would be varId,\n            // but backwards compatibility :/\n            paramId: p.getId(),\n          };\n        });\n      }\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function (state) {\n    const map = this.workspace.getProcedureMap();\n\n    const procedureId = state['procedureId'];\n    if (map.has(procedureId) && !state['fullSerialization']) {\n      if (map.has(this.model_.getId())) {\n        map.delete(this.model_.getId());\n      }\n      this.model_ = map.get(procedureId);\n    }\n\n    const model = this.getProcedureModel();\n    const newParams = state['params'] ?? [];\n    const newIds = new Set(newParams.map((p) => p.id));\n    const currParams = model.getParameters();\n    if (state['fullSerialization']) {\n      for (let i = currParams.length - 1; i >= 0; i--) {\n        if (!newIds.has(currParams[i].getId)) {\n          model.deleteParameter(i);\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i++) {\n      const {name, id, paramId} = state['params'][i];\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(this.workspace, name, paramId, id),\n        i,\n      );\n    }\n\n    this.doProcedureUpdate();\n    this.setStatements_(state['hasStatements'] === false ? false : true);\n  },\n\n  /**\n   * Populate the mutator's dialog with this block's components.\n   *\n   * @param workspace Blockly.Mutator's workspace.\n   * @returns Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  decompose: function (workspace) {\n    const containerBlockDef = {\n      type: 'procedures_mutatorcontainer',\n      inputs: {\n        STACK: {},\n      },\n    };\n\n    let connDef = containerBlockDef['inputs']['STACK'];\n    for (const param of this.getProcedureModel().getParameters()) {\n      connDef['block'] = {\n        type: 'procedures_mutatorarg',\n        id: param.getId(),\n        fields: {\n          NAME: param.getName(),\n        },\n        next: {},\n      };\n      connDef = connDef['block']['next'];\n    }\n\n    const containerBlock = Blockly.serialization.blocks.append(\n      containerBlockDef as unknown as Blockly.serialization.blocks.State,\n      workspace,\n      {recordUndo: false},\n    );\n\n    if (this.type === 'procedures_defreturn') {\n      containerBlock.setFieldValue(this.hasStatements_, 'STATEMENTS');\n    } else {\n      containerBlock.removeInput('STATEMENT_INPUT');\n    }\n\n    return containerBlock;\n  },\n\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   *\n   * @param containerBlock Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  compose: function (containerBlock) {\n    // Note that only one of these four things can actually occur for any given\n    // composition, because the user can only drag blocks around so quickly.\n    // So we can use that when making assumptions inside the definitions of\n    // these sub procedures.\n    this.deleteParamsFromModel_(containerBlock);\n    this.renameParamsInModel_(containerBlock);\n    this.addParamsToModel_(containerBlock);\n\n    const hasStatements = containerBlock.getFieldValue('STATEMENTS');\n    if (hasStatements !== null) {\n      this.setStatements_(hasStatements === 'TRUE');\n    }\n  },\n\n  /**\n   * Deletes any parameters from the procedure model that do not have associated\n   * parameter blocks in the mutator.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  deleteParamsFromModel_: function (containerBlock) {\n    const ids = new Set(containerBlock.getDescendants().map((b) => b.id));\n    const model = this.getProcedureModel();\n    const count = model.getParameters().length;\n    for (let i = count - 1; i >= 0; i--) {\n      if (!ids.has(model.getParameter(i).getId())) {\n        model.deleteParameter(i);\n      }\n    }\n  },\n\n  /**\n   * Renames any parameters in the procedure model whose associated parameter\n   * blocks have been renamed.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  renameParamsInModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      const param = model.getParameter(i);\n      if (\n        param &&\n        param.getId() === paramBlock.id &&\n        param.getName() !== paramBlock.getFieldValue('NAME')\n      ) {\n        param.setName(paramBlock.getFieldValue('NAME'));\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n\n  /**\n   * Adds new parameters to the procedure model for any new procedure parameter\n   * blocks.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  addParamsToModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      if (\n        !model.getParameter(i) ||\n        model.getParameter(i).getId() !== paramBlock.id\n      ) {\n        model.insertParameter(\n          new ObservableParameterModel(\n            this.workspace,\n            paramBlock.getFieldValue('NAME'),\n            paramBlock.id,\n          ),\n          i,\n        );\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_def_mutator',\n  procedureDefMutator,\n  undefined,\n  ['procedures_mutatorarg'],\n);\n\nconst procedureDefContextMenuMixin = {\n  /**\n   * Add custom menu options to this block's context menu.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (\n    options: Array<\n      | Blockly.ContextMenuRegistry.ContextMenuOption\n      | Blockly.ContextMenuRegistry.LegacyContextMenuOption\n    >,\n  ) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    const xmlMutation = Blockly.utils.xml.createElement('mutation');\n    xmlMutation.setAttribute('name', this.getFieldValue('NAME'));\n    const params = this.getProcedureModel().getParameters();\n    for (const param of params) {\n      const xmlArg = Blockly.utils.xml.createElement('arg');\n      xmlArg.setAttribute('name', param.getName());\n      xmlMutation.appendChild(xmlArg);\n    }\n    const xmlBlock = Blockly.utils.xml.createElement('block');\n    xmlBlock.setAttribute('type', this.callType_);\n    xmlBlock.appendChild(xmlMutation);\n\n    // Add option to create caller.\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_CREATE_DO'].replace(\n        '%1',\n        this.getFieldValue('NAME'),\n      ),\n      callback: Blockly.ContextMenu.callbackFactory(\n        this,\n        xmlBlock,\n      ) as () => void,\n    });\n\n    // Add options to create getters for each parameter.\n    if (this.isCollapsed()) return;\n\n    for (const param of params) {\n      const argVar = param.getVariableModel();\n      const argXmlField = Blockly.Variables.generateVariableFieldDom(argVar);\n      const argXmlBlock = Blockly.utils.xml.createElement('block');\n      argXmlBlock.setAttribute('type', 'variables_get');\n      argXmlBlock.appendChild(argXmlField);\n      options.push({\n        enabled: true,\n        text: Blockly.Msg['VARIABLES_SET_CREATE_GET'].replace(\n          '%1',\n          argVar.name,\n        ),\n        callback: Blockly.ContextMenu.callbackFactory(\n          this,\n          argXmlBlock,\n        ) as () => void,\n      });\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_context_menu_mixin',\n  procedureDefContextMenuMixin,\n);\n\nconst procedureDefOnChangeMixin = {\n  onchange: function (e) {\n    if (e.type === Blockly.Events.BLOCK_CREATE && e.blockId === this.id) {\n      Blockly.Events.fire(\n        new ProcedureCreate(this.workspace, this.getProcedureModel()),\n      );\n    }\n    if (\n      e.type === Blockly.Events.BLOCK_CHANGE &&\n      e.blockId === this.id &&\n      e.element === 'disabled'\n    ) {\n      this.getProcedureModel().setEnabled(!e.newValue);\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_onchange_mixin',\n  procedureDefOnChangeMixin,\n);\n\nconst procedureDefNoReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defnoreturn_set_comment_helper',\n  procedureDefNoReturnSetCommentHelper,\n);\n\nconst procedureDefReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defreturn_set_comment_helper',\n  procedureDefReturnSetCommentHelper,\n);\n\nconst procedureDefNoReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defnoreturn_get_caller_block_mixin',\n  procedureDefNoReturnGetCallerBlockMixin,\n);\n\nconst procedureDefReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defreturn_get_caller_block_mixin',\n  procedureDefReturnGetCallerBlockMixin,\n);\n\nconst procedureDefSetNoReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes(null);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_no_return_helper',\n  procedureDefSetNoReturnHelper,\n);\n\nconst procedureDefSetReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes([]);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_return_helper',\n  procedureDefSetReturnHelper,\n);\n\nconst procedureCallerGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    prevParams_: [],\n\n    argsMap_: new Map(),\n\n    /**\n     * Returns the procedure model associated with this block.\n     *\n     * @returns The procedure model associated with this block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * Returns the procedure model tha was found.\n     *\n     * @param name The name of the procedure model to find.\n     * @param params The param names of the procedure model\n     *     to find.\n     * @returns The procedure model that was found.\n     */\n    findProcedureModel_(name, params = []) {\n      const workspace = this.getTargetWorkspace_();\n      const model = workspace\n        .getProcedureMap()\n        .getProcedures()\n        .find((proc) => proc.getName() === name);\n      if (!model) return null;\n\n      const returnTypes = model.getReturnTypes();\n      const hasMatchingReturn = this.hasReturn_ ? returnTypes : !returnTypes;\n      if (!hasMatchingReturn) return null;\n\n      const hasMatchingParams = model\n        .getParameters()\n        .every((p, i) => p.getName() === params[i]);\n      if (!hasMatchingParams) return null;\n\n      return model;\n    },\n\n    /**\n     * Returns the main workspace (i.e. not the flyout workspace) associated\n     * with this block.\n     *\n     * @returns The main workspace (i.e. not the flyout workspace) associated\n     *     with this block.\n     */\n    getTargetWorkspace_() {\n      return this.workspace.isFlyout\n        ? this.workspace.targetWorkspace\n        : this.workspace;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns False because this is not a procedure definition block.\n     */\n    isProcedureDef() {\n      return false;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_get_def_mixin',\n  procedureCallerGetDefMixin,\n);\n\nconst procedureCallerVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_var_mixin',\n  procedureCallerVarMixin,\n);\n\nconst procedureCallerMutator = {\n  previousEnabledState_: true,\n\n  paramsFromSerializedState_: [],\n\n  /**\n   * Create XML to represent the (non-editable) name and arguments.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const model = this.getProcedureModel();\n    if (!model) return container;\n\n    container.setAttribute('name', model.getName());\n    for (const param of model.getParameters()) {\n      const arg = Blockly.utils.xml.createElement('arg');\n      arg.setAttribute('name', param.getName());\n      container.appendChild(arg);\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the (non-editable) name and parameters.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const name = xmlElement.getAttribute('name');\n    const params = [];\n    for (const n of xmlElement.childNodes) {\n      if (n.nodeName.toLowerCase() === 'arg') {\n        params.push(n.getAttribute('name'));\n      }\n    }\n    this.deserialize_(name, params);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of\n   *     this block, ie the params and procedure name.\n   */\n  saveExtraState: function () {\n    const state = Object.create(null);\n    const model = this.getProcedureModel();\n    if (!model) {\n      // We reached here because we've deserialized a caller into a workspace\n      // where its model did not already exist (no procedures array in the json,\n      // and deserialized before any definition block), and are reserializing\n      // it before the event delay has elapsed and change listeners have run.\n      // (If they had run, we would have found or created a model).\n      // Just reserialize any deserialized state. Nothing should have happened\n      // in-between to change it.\n      state['name'] = this.getFieldValue('NAME');\n      state['params'] = this.paramsFromSerializedState_;\n      return state;\n    }\n    state['name'] = model.getName();\n    if (model.getParameters().length) {\n      state['params'] = model.getParameters().map((p) => p.getName());\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the params and\n   *     procedure name.\n   */\n  loadExtraState: function (state) {\n    this.deserialize_(state['name'], state['params'] || []);\n  },\n\n  /**\n   * Applies the given name and params from the serialized state to the block.\n   *\n   * @param name The name to apply to the block.\n   * @param params The parameters to apply to the block.\n   */\n  deserialize_: function (name, params) {\n    this.setFieldValue(name, 'NAME');\n    if (!this.model_) this.model_ = this.findProcedureModel_(name, params);\n    if (this.getProcedureModel()) {\n      this.initBlockWithProcedureModel_();\n    } else {\n      // Create inputs based on the mutation so that children can be connected.\n      this.createArgInputs_(params);\n    }\n    this.paramsFromSerializedState_ = params;\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_caller_mutator',\n  procedureCallerMutator,\n);\n\nconst procedureCallerUpdateShapeMixin = {\n  /**\n   * Renders the block for the first time based on the procedure model.\n   */\n  initBlockWithProcedureModel_() {\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n    this.doProcedureUpdate();\n  },\n\n  /**\n   * Updates the shape of this block to reflect the state of the data model.\n   */\n  doProcedureUpdate: function () {\n    if (!this.getProcedureModel()) return;\n    const id = this.getProcedureModel().getId();\n    if (!this.getTargetWorkspace_().getProcedureMap().has(id)) {\n      this.dispose();\n      return;\n    }\n    this.updateName_();\n    this.updateEnabled_();\n    this.updateParameters_();\n  },\n\n  /**\n   * Updates the name field of this block to match the state of the data model.\n   */\n  updateName_: function () {\n    const name = this.getProcedureModel().getName();\n    this.setFieldValue(name, 'NAME');\n    const baseMsg = this.outputConnection\n      ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n      : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n    this.setTooltip(baseMsg.replace('%1', name));\n  },\n\n  /**\n   * Updates the enabled state of this block to match the state of the data\n   *     model.\n   */\n  updateEnabled_: function () {\n    if (!this.getProcedureModel().getEnabled()) {\n      this.previousEnabledState_ = this.isEnabled();\n      this.setEnabled(false);\n    } else {\n      this.setEnabled(this.previousEnabledState_);\n    }\n  },\n\n  /**\n   * Updates the parameter fields/inputs of this block to match the state of the\n   * data model.\n   */\n  updateParameters_: function () {\n    this.syncArgsMap_();\n    this.deleteAllArgInputs_();\n    this.addParametersLabel__();\n    this.createArgInputs_();\n    this.reattachBlocks_();\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n  },\n\n  /**\n   * Makes sure that if we are updating the parameters before any move events\n   * have happened, the args map records the current state of the block. Does\n   * not remove entries from the array, since blocks can be disconnected\n   * temporarily during mutation (which triggers this method).\n   */\n  syncArgsMap_: function () {\n    // We look at the prevParams array because the current state of the block\n    // matches the old params, not the new params state.\n    for (const [i, p] of this.prevParams_.entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) this.argsMap_.set(p.getId(), target);\n    }\n  },\n\n  /**\n   * Saves a map of parameter IDs to target blocks attached to the inputs\n   * of this caller block.\n   */\n  updateArgsMap_: function () {\n    for (const [i, p] of this.getProcedureModel().getParameters().entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) {\n        this.argsMap_.set(p.getId(), target);\n      } else {\n        this.argsMap_.delete(p.getId());\n      }\n    }\n  },\n\n  /**\n   * Deletes all the parameter inputs on this block.\n   */\n  deleteAllArgInputs_: function () {\n    let i = 0;\n    while (this.getInput(`ARG${i}`)) {\n      this.removeInput(`ARG${i}`);\n      i++;\n    }\n  },\n\n  /**\n   * Adds or removes the parameter label to match the state of the data model.\n   */\n  addParametersLabel__: function () {\n    const topRow = this.getInput('TOPROW');\n    if (this.getProcedureModel().getParameters().length) {\n      if (!this.getField('WITH')) {\n        topRow.appendField(\n          Blockly.Msg['PROCEDURES_CALL_BEFORE_PARAMS'],\n          'WITH',\n        );\n        topRow.init();\n      }\n    } else if (this.getField('WITH')) {\n      topRow.removeField('WITH');\n    }\n  },\n\n  /**\n   * Creates all of the parameter inputs to match the state of the data model.\n   *\n   * @param params The params to add to the block, or null to\n   *     use the params defined in the procedure model.\n   */\n  createArgInputs_: function (params = null) {\n    if (!params) {\n      params = this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getName());\n    }\n    for (const [i, p] of params.entries()) {\n      this.appendValueInput(`ARG${i}`)\n        .appendField(new Blockly.FieldLabel(p), `ARGNAME${i}`)\n        .setAlign(Blockly.Input.Align.RIGHT);\n    }\n  },\n\n  /**\n   * Reattaches blocks to this blocks' inputs based on the data saved in the\n   * argsMap_.\n   */\n  reattachBlocks_: function () {\n    const params = this.getProcedureModel().getParameters();\n    for (const [i, p] of params.entries()) {\n      if (!this.argsMap_.has(p.getId())) continue;\n      this.getInput(`ARG${i}`).connection.connect(\n        this.argsMap_.get(p.getId()).outputConnection,\n      );\n    }\n  },\n\n  /**\n   * Notification that a procedure is renaming.\n   * If the name matches this block's procedure, rename it.\n   *\n   * @param oldName Previous name of procedure.\n   * @param newName Renamed procedure.\n   * @this {Blockly.Block}\n   */\n  renameProcedure: function (oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('NAME'))) {\n      this.setFieldValue(newName, 'NAME');\n      const baseMsg = this.outputConnection\n        ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n        : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n      this.setTooltip(baseMsg.replace('%1', newName));\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_update_shape_mixin',\n  procedureCallerUpdateShapeMixin,\n);\n\nconst procedureCallerOnChangeMixin = {\n  /**\n   * Procedure calls cannot exist without the corresponding procedure\n   * definition.  Enforce this link whenever an event is fired.\n   *\n   * @param event Change event.\n   * @this {Blockly.Block}\n   */\n  onchange: function (event) {\n    if (this.disposed || this.workspace.isFlyout) return;\n    if (event.type === Blockly.Events.BLOCK_MOVE) this.updateArgsMap_(true);\n    if (\n      event.type !== Blockly.Events.FINISHED_LOADING &&\n      !this.eventIsCreatingThisBlockDuringPaste_(event)\n    )\n      return;\n\n    // We already found our model, which means we don't need to create a block.\n    if (this.getProcedureModel()) return;\n\n    // Look for the case where a procedure call was created (usually through\n    // paste) and there is no matching definition.  In this case, create\n    // an empty definition block with the correct signature.\n    const name = this.getFieldValue('NAME');\n    let def = Blockly.Procedures.getDefinition(name, this.workspace);\n    if (!this.defMatches_(def)) def = null;\n    if (!def) {\n      // We have no def nor procedure model.\n      Blockly.Events.setGroup(event.group);\n      this.model_ = this.createDef_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n      Blockly.Events.setGroup(false);\n    }\n    if (!this.getProcedureModel()) {\n      // We have a def, but no reference to its model.\n      this.model_ = this.findProcedureModel_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n    }\n    this.initBlockWithProcedureModel_();\n  },\n\n  /**\n   * @param event The event to check.\n   * @returns True if the given event is a paste event for this block.\n   */\n  eventIsCreatingThisBlockDuringPaste_(event) {\n    return (\n      event.type === Blockly.Events.BLOCK_CREATE &&\n      (event.blockId === this.id || event.ids.indexOf(this.id) !== -1) &&\n      // Record undo makes sure this is during paste.\n      event.recordUndo\n    );\n  },\n\n  /**\n   * Returns true if the given def block matches the definition of this caller\n   * block.\n   *\n   * @param defBlock The definition block to check against.\n   * @returns Whether the def block matches or not.\n   */\n  defMatches_(defBlock) {\n    return (\n      defBlock &&\n      defBlock.type === this.defType_ &&\n      JSON.stringify(defBlock.getVars()) ===\n        JSON.stringify(this.paramsFromSerializedState_)\n    );\n  },\n\n  /**\n   * Creates a procedure definition block with the given name and params,\n   * and returns the procedure model associated with it.\n   *\n   * @param name The name of the procedure to create.\n   * @param params The names of the parameters to create.\n   * @returns The procedure model associated with the new\n   *     procedure definition block.\n   */\n  createDef_(name, params = []) {\n    const xy = this.getRelativeToSurfaceXY();\n    const newName = Blockly.Procedures.findLegalName(name, this);\n    this.renameProcedure(name, newName);\n\n    const blockDef = {\n      type: this.defType_,\n      x: xy.x + Blockly.config.snapRadius * (this.RTL ? -1 : 1),\n      y: xy.y + Blockly.config.snapRadius * 2,\n      extraState: {\n        params: params.map((p) => ({name: p})),\n      },\n      fields: {NAME: newName},\n    };\n    const block = Blockly.serialization.blocks.append(\n      blockDef,\n      this.getTargetWorkspace_(),\n      {recordUndo: true},\n    );\n    return (block as unknown as IProcedureBlock).getProcedureModel();\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_onchange_mixin',\n  procedureCallerOnChangeMixin,\n);\n\nconst procedureCallerContextMenuMixin = {\n  /**\n   * Add menu option to find the definition block for this call.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (options) {\n    if (!this.workspace.isMovable()) {\n      // If we center on the block and the workspace isn't movable we could\n      // lose blocks at the edges of the workspace.\n      return;\n    }\n\n    const name = this.getFieldValue('NAME');\n    const workspace = this.workspace;\n    const callback = function () {\n      const def = Blockly.Procedures.getDefinition(name, workspace);\n      if (def && def instanceof Blockly.BlockSvg) {\n        workspace.centerOnBlock(def.id);\n        def.select();\n      }\n    };\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_HIGHLIGHT_DEF'],\n      callback: callback,\n    });\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_context_menu_mixin',\n  procedureCallerContextMenuMixin,\n);\n\nconst procedureCallerNoReturnGetDefBlockMixin = {\n  hasReturn_: false,\n  defType_: 'procedures_defnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callernoreturn_get_def_block_mixin',\n  procedureCallerNoReturnGetDefBlockMixin,\n);\n\nconst procedureCallerReturnGetDefBlockMixin = {\n  hasReturn_: true,\n  defType_: 'procedures_defreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callerreturn_get_def_block_mixin',\n  procedureCallerReturnGetDefBlockMixin,\n);\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/** The interface for a block which models a procedure. */\nexport interface IProcedureBlock {\n  getProcedureModel(): Blockly.procedures.IProcedureModel;\n  doProcedureUpdate(): void;\n  isProcedureDef(): boolean;\n}\n\n/**\n * A type guard which checks if the given block is a procedure block.\n *\n * @param block The block to check for procedure-y-ness.\n * @returns Whether this block is a procedure block or not.\n */\nexport function isProcedureBlock(\n  block: Blockly.Block | IProcedureBlock,\n): block is IProcedureBlock {\n  return (\n    (block as IProcedureBlock).getProcedureModel !== undefined &&\n    (block as IProcedureBlock).doProcedureUpdate !== undefined &&\n    (block as IProcedureBlock).isProcedureDef !== undefined\n  );\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\nexport {blocks} from './blocks';\nexport {IProcedureBlock, isProcedureBlock} from './i_procedure_block';\nexport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nexport {\n  ProcedureChangeReturn,\n  ProcedureChangeReturnJson,\n} from './events_procedure_change_return';\nexport {ProcedureCreate, ProcedureCreateJson} from './events_procedure_create';\nexport {ProcedureDelete, ProcedureDeleteJson} from './events_procedure_delete';\nexport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nexport {\n  ProcedureParameterCreate,\n  ProcedureParameterCreateJson,\n} from './events_procedure_parameter_create';\nexport {\n  ProcedureParameterDelete,\n  ProcedureParameterDeleteJson,\n} from './events_procedure_parameter_delete';\nexport {\n  ProcedureParameterRename,\n  ProcedureParameterRenameJson,\n} from './events_procedure_parameter_rename';\nexport {ProcedureRename, ProcedureRenameJson} from './events_procedure_rename';\nexport {triggerProceduresUpdate} from './update_procedures';\n\nexport {ObservableParameterModel, ObservableProcedureModel};\n\n/**\n * Unregisters all of the procedure blocks.\n *\n * Usually used to unregister the built-in blocks, before register the\n * blocks provided by this plugin.\n */\nexport function unregisterProcedureBlocks() {\n  delete Blockly.Blocks['procedures_defnoreturn'];\n  delete Blockly.Blocks['procedures_callnoreturn'];\n  delete Blockly.Blocks['procedures_defreturn'];\n  delete Blockly.Blocks['procedures_callreturn'];\n}\n\n/**\n * Unregisters any existing procedure serializer, and registers a new one\n * parameterized with the shareable procedure backing data models.\n */\nexport function registerProcedureSerializer() {\n  Blockly.serialization.registry.unregister('procedures');\n  Blockly.serialization.registry.register(\n    'procedures',\n    new Blockly.serialization.procedures.ProcedureSerializer(\n      ObservableProcedureModel,\n      ObservableParameterModel,\n    ),\n  );\n}\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "a", "i", "this", "__WEBPACK_EXTERNAL_MODULE__573__", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "t", "e", "ProcedureBase", "constructor", "workspace", "procedure", "super", "type", "TYPE", "isBlank", "workspaceId", "id", "toJson", "json", "getId", "ProcedureParameterBase", "parameter", "recordUndo", "static", "procedureId", "paramId", "getProcedureMap", "undefined", "getParameters", "find", "p", "ProcedureParameterRename", "oldName", "newName", "newVarId", "getName", "getVariableModel", "run", "forward", "findMatchingParameter", "getEventWorkspace_", "setName", "Error", "triggerProceduresUpdate", "isClearing", "block", "getAllBlocks", "doProcedureUpdate", "ObservableParameterModel", "name", "varId", "shouldFireEvents", "procedureModel", "variable", "createBackingVariable", "s", "getVariable", "createVariable", "setTypes", "types", "getTypes", "startPublishing", "stopPublishing", "setProcedureModel", "model", "ProcedureChangeReturn", "workpace", "oldTypes", "newTypes", "getReturnTypes", "setReturnTypes", "ProcedureCreate", "procedureMap", "add", "delete", "ObservableProcedureModel", "ProcedureDelete", "ProcedureEnable", "newState", "oldState", "getEnabled", "setEnabled", "ProcedureParameterCreate", "index", "insertParameter", "deleteParameter", "ProcedureParameterDelete", "ProcedureRename", "parameters", "returnTypes", "enabled", "shouldTriggerUpdates", "parameterModel", "splice", "oldParam", "length", "oldReturnTypes", "startBulkUpdate", "endBulkUpdate", "getParameter", "param", "blocks", "message0", "message1", "args0", "text", "spellcheck", "args1", "style", "helpUrl", "tooltip", "extensions", "mutator", "nextStatement", "previousStatement", "message2", "args2", "align", "output", "mixin", "model_", "getProcedureModel", "isProcedureDef", "getVars", "map", "getVarModels", "destroy", "getFieldValue", "renameVarById", "oldId", "newId", "oldVar", "getVariableById", "findIndex", "newVar", "updateVarName", "some", "procedureDefUpdateShapeMixin", "setFieldValue", "updateParameters_", "updateMutator_", "params", "paramString", "join", "getIcon", "bubbleIsVisible", "mutatorWorkspace", "getWorkspace", "getBlockById", "setStatements_", "hasStatements", "hasStatements_", "appendStatementInput", "appendField", "getInput", "moveInputBefore", "statementConnection_", "stackConnection", "connection", "targetConnection", "stackBlock", "targetBlock", "unplug", "bumpNeighbours", "removeInput", "nameField", "getField", "setValue", "setValidator", "procedureDefMutator", "mutationToDom", "container", "varModel", "setAttribute", "appendChild", "domToMutation", "xmlElement", "childNodes", "node", "nodeName", "toLowerCase", "getAttribute", "saveExtraState", "doFullSerialization", "state", "create", "loadExtraState", "has", "newParams", "newIds", "Set", "currParams", "decompose", "containerBlockDef", "inputs", "STACK", "connDef", "fields", "NAME", "next", "containerBlock", "compose", "deleteParamsFromModel_", "renameParamsInModel_", "addParamsToModel_", "ids", "getDescendants", "b", "paramBlock", "getInputTargetBlock", "isInsertionMarker", "nextConnection", "procedureDefContextMenuMixin", "customContextMenu", "options", "isInFlyout", "xmlMutation", "xmlArg", "xmlBlock", "callType_", "push", "callback", "isCollapsed", "argVar", "argXmlField", "argXmlBlock", "procedureDefOnChangeMixin", "onchange", "blockId", "element", "newValue", "comments", "parentWorkspace", "setCommentText", "prevParams_", "argsMap_", "Map", "findProcedureModel_", "getTargetWorkspace_", "getProcedures", "proc", "hasReturn_", "every", "isFlyout", "targetWorkspace", "procedureCallerMutator", "previousEnabledState_", "paramsFromSerializedState_", "arg", "n", "deserialize_", "initBlockWithProcedureModel_", "createArgInputs_", "procedureCallerUpdateShapeMixin", "updateName_", "updateEnabled_", "dispose", "baseMsg", "outputConnection", "setTooltip", "replace", "isEnabled", "syncArgsMap_", "deleteAllArgInputs_", "addParametersLabel__", "reattachBlocks_", "entries", "target", "set", "updateArgsMap_", "topRow", "init", "removeField", "appendValueInput", "setAlign", "connect", "renameProcedure", "procedureCallerOnChangeMixin", "event", "disposed", "eventIsCreatingThisBlockDuringPaste_", "def", "defMatches_", "group", "createDef_", "indexOf", "defBlock", "defType_", "JSON", "stringify", "xy", "getRelativeToSurfaceXY", "blockDef", "x", "RTL", "y", "extraState", "procedureCallerContextMenuMixin", "isMovable", "centerOnBlock", "select", "isProcedureBlock", "unregisterProcedureBlocks", "registerProcedureSerializer"]
}

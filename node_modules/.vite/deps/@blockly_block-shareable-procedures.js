import {
  __commonJS,
  require_core_browser
} from "./chunk-PWNPSN2K.js";

// node_modules/@blockly/block-shareable-procedures/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blockly/block-shareable-procedures/dist/index.js"(exports, module) {
    !function(e, t) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t(require_core_browser());
      else if ("function" == typeof define && define.amd) define(["blockly/core"], t);
      else {
        var r = "object" == typeof exports ? t(require_core_browser()) : t(e.Blockly);
        for (var s in r) ("object" == typeof exports ? exports : e)[s] = r[s];
      }
    }(exports, (e) => (() => {
      "use strict";
      var t = { 573: (t2) => {
        t2.exports = e;
      } }, r = {};
      function s(e2) {
        var o2 = r[e2];
        if (void 0 !== o2) return o2.exports;
        var i = r[e2] = { exports: {} };
        return t[e2](i, i.exports, s), i.exports;
      }
      s.d = (e2, t2) => {
        for (var r2 in t2) s.o(t2, r2) && !s.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
      }, s.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), s.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var o = {};
      return (() => {
        s.r(o), s.d(o, { ObservableParameterModel: () => a, ObservableProcedureModel: () => m, ProcedureBase: () => t2, ProcedureChangeReturn: () => d, ProcedureCreate: () => c, ProcedureDelete: () => u, ProcedureParameterBase: () => r2, ProcedureParameterCreate: () => p, ProcedureParameterDelete: () => h, ProcedureParameterRename: () => i, ProcedureRename: () => g, blocks: () => _, isProcedureBlock: () => y, registerProcedureSerializer: () => w, triggerProceduresUpdate: () => n, unregisterProcedureBlocks: () => R });
        var e2 = s(573);
        class t2 extends e2.Events.Abstract {
          constructor(e3, r3) {
            super(), this.procedure = r3, this.type = t2.TYPE, this.isBlank = false, this.workspaceId = e3.id;
          }
          toJson() {
            const e3 = super.toJson();
            return e3.procedureId = this.procedure.getId(), e3;
          }
        }
        t2.TYPE = "procedure_base";
        class r2 extends t2 {
          constructor(e3, t3, s2) {
            super(e3, t3), this.parameter = s2, this.type = r2.TYPE, this.recordUndo = false;
          }
          static findMatchingParameter(e3, t3, r3) {
            const s2 = e3.getProcedureMap().get(t3);
            if (!s2) return { procedure: void 0, parameter: void 0 };
            const o2 = s2.getParameters().find((e4) => e4.getId() === r3);
            return o2 ? { procedure: s2, parameter: o2 } : { procedure: s2, parameter: void 0 };
          }
          toJson() {
            const e3 = super.toJson();
            return e3.parameterId = this.parameter.getId(), e3;
          }
        }
        r2.TYPE = "procedure_parameter_base";
        class i extends r2 {
          constructor(e3, t3, r3, s2, o2, n2) {
            super(e3, t3, r3), this.oldName = s2, this.type = i.TYPE, this.newName = null != o2 ? o2 : r3.getName(), this.newVarId = null != n2 ? n2 : r3.getVariableModel().getId();
          }
          run(e3) {
            const { parameter: t3 } = r2.findMatchingParameter(this.getEventWorkspace_(), this.procedure.getId(), this.parameter.getId());
            if (e3) {
              if (t3.getName() !== this.oldName) return;
              t3.setName(this.newName, this.newVarId);
            } else {
              if (t3.getName() !== this.newName) return;
              t3.setName(this.oldName);
            }
          }
          toJson() {
            const e3 = super.toJson();
            return e3.newName = this.newName, e3.newVarId = this.newVarId, e3.oldName = this.oldName, e3;
          }
          static fromJson(e3, t3) {
            const { procedure: s2, parameter: o2 } = r2.findMatchingParameter(t3, e3.procedureId, e3.parameterId);
            if (!o2) throw new Error("Cannot delete a non existant parameter");
            return new i(t3, s2, o2, e3.oldName, e3.newName, e3.newVarId);
          }
        }
        function n(t3) {
          if (!t3.isClearing) for (const r3 of t3.getAllBlocks(false)) e2.procedures.isProcedureBlock(r3) && r3.doProcedureUpdate();
        }
        i.TYPE = "procedure_parameter_rename", e2.registry.register(e2.registry.Type.EVENT, i.TYPE, i);
        class a {
          constructor(t3, r3, s2, o2) {
            this.workspace = t3, this.shouldFireEvents = false, this.procedureModel = null, this.id = null != s2 ? s2 : e2.utils.idGenerator.genUid(), this.variable = this.createBackingVariable(r3, o2);
          }
          setName(t3, r3) {
            var s2;
            if (t3 === this.variable.name) return this;
            const o2 = this.variable.name;
            return this.variable = null !== (s2 = this.workspace.getVariable(t3)) && void 0 !== s2 ? s2 : this.workspace.createVariable(t3, "", r3), n(this.workspace), this.shouldFireEvents && e2.Events.fire(new i(this.workspace, this.procedureModel, this, o2)), this;
          }
          createBackingVariable(e3, t3) {
            var r3;
            return this.variable = null !== (r3 = this.workspace.getVariable(e3)) && void 0 !== r3 ? r3 : this.workspace.createVariable(e3, "", t3), this.variable;
          }
          setTypes(e3) {
            throw new Error("The built-in ParameterModel does not support typing. You need to implement your own custom ParameterModel.");
          }
          getName() {
            return this.variable.name;
          }
          getTypes() {
            return [];
          }
          getId() {
            return this.id;
          }
          getVariableModel() {
            return this.variable;
          }
          startPublishing() {
            this.shouldFireEvents = true;
          }
          stopPublishing() {
            this.shouldFireEvents = false;
          }
          setProcedureModel(e3) {
            return this.procedureModel = e3, this;
          }
        }
        class d extends t2 {
          constructor(e3, t3, r3) {
            super(e3, t3), this.oldTypes = r3, this.type = d.TYPE, this.newTypes = t3.getReturnTypes();
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap().get(this.procedure.getId());
            if (!t3) throw new Error("Cannot change the type of a procedure that does not exist in the procedure map");
            e3 ? t3.setReturnTypes(this.newTypes) : t3.setReturnTypes(this.oldTypes);
          }
          toJson() {
            const e3 = super.toJson();
            return e3.oldTypes = this.oldTypes, e3;
          }
          static fromJson(e3, t3) {
            const r3 = t3.getProcedureMap().get(e3.procedureId);
            if (!r3) throw new Error("Cannot deserialize procedure change return event because the target procedure does not exist");
            return new d(t3, r3, e3.oldTypes);
          }
        }
        d.TYPE = "procedure_change", e2.registry.register(e2.registry.Type.EVENT, d.TYPE, d);
        class c extends t2 {
          constructor() {
            super(...arguments), this.type = c.TYPE;
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap();
            if (e3) {
              if (t3.get(this.procedure.getId())) return;
              t3.add(this.procedure);
            } else {
              if (!t3.get(this.procedure.getId())) return;
              t3.delete(this.procedure.getId());
            }
          }
          toJson() {
            const t3 = super.toJson();
            return t3.procedure = e2.serialization.procedures.saveProcedure(this.procedure), t3;
          }
          static fromJson(t3, r3) {
            return new c(r3, e2.serialization.procedures.loadProcedure(m, a, t3.procedure, r3));
          }
        }
        c.TYPE = "procedure_create", e2.registry.register(e2.registry.Type.EVENT, c.TYPE, c);
        class u extends t2 {
          constructor() {
            super(...arguments), this.type = u.TYPE;
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap();
            if (e3) {
              if (!t3.get(this.procedure.getId())) return;
              t3.delete(this.procedure.getId());
            } else {
              if (t3.get(this.procedure.getId())) return;
              t3.add(this.procedure);
            }
          }
          toJson() {
            return super.toJson();
          }
          static fromJson(e3, t3) {
            const r3 = t3.getProcedureMap().get(e3.procedureId);
            if (!r3) throw new Error("Cannot deserialize procedure delete event because the target procedure does not exist");
            return new u(t3, r3);
          }
        }
        u.TYPE = "procedure_delete", e2.registry.register(e2.registry.Type.EVENT, u.TYPE, u);
        class l extends t2 {
          constructor(e3, t3, r3) {
            super(e3, t3), this.type = l.TYPE, void 0 === r3 ? (this.oldState = !t3.getEnabled(), this.newState = t3.getEnabled()) : (this.oldState = !r3, this.newState = r3);
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap().get(this.procedure.getId());
            if (!t3) throw new Error("Cannot change the enabled state of a procedure that does not exist in the procedure map");
            e3 ? t3.setEnabled(this.newState) : t3.setEnabled(this.oldState);
          }
          toJson() {
            const e3 = super.toJson();
            return e3.newState = this.newState, e3;
          }
          static fromJson(e3, t3) {
            const r3 = t3.getProcedureMap().get(e3.procedureId);
            if (!r3) throw new Error("Cannot deserialize procedure enable event because the target procedure does not exist");
            return new l(t3, r3, e3.newState);
          }
        }
        l.TYPE = "procedure_enable", e2.registry.register(e2.registry.Type.EVENT, l.TYPE, l);
        class p extends r2 {
          constructor(e3, t3, r3, s2) {
            super(e3, t3, r3), this.index = s2, this.type = p.TYPE;
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap().get(this.procedure.getId());
            if (!t3) throw new Error("Cannot add a parameter to a procedure that does not exist in the procedure map");
            e3 ? t3.insertParameter(this.parameter, this.index) : t3.deleteParameter(this.index);
          }
          toJson() {
            const e3 = super.toJson();
            return e3.name = this.parameter.getName(), e3.id = this.parameter.getId(), e3.varId = this.parameter.getVariableModel().getId(), e3.index = this.index, e3;
          }
          static fromJson(e3, t3) {
            const r3 = t3.getProcedureMap().get(e3.procedureId);
            if (!r3) throw new Error("Cannot deserialize parameter create event because the target procedure does not exist");
            return new p(t3, r3, new a(t3, e3.name, e3.id, e3.varId), e3.index);
          }
        }
        p.TYPE = "procedure_parameter_create", e2.registry.register(e2.registry.Type.EVENT, p.TYPE, p);
        class h extends r2 {
          constructor(e3, t3, r3, s2) {
            super(e3, t3, r3), this.index = s2, this.type = h.TYPE;
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap().get(this.procedure.getId());
            if (!t3) throw new Error("Cannot add a parameter to a procedure that does not exist in the procedure map");
            e3 ? t3.deleteParameter(this.index) : t3.insertParameter(this.parameter, this.index);
          }
          toJson() {
            const e3 = super.toJson();
            return e3.index = this.index, e3;
          }
          static fromJson(e3, t3) {
            const { procedure: s2, parameter: o2 } = r2.findMatchingParameter(t3, e3.procedureId, e3.parameterId);
            if (!o2) throw new Error("Cannot delete a non existant parameter");
            return new h(t3, s2, o2, e3.index);
          }
        }
        h.TYPE = "procedure_parameter_delete", e2.registry.register(e2.registry.Type.EVENT, h.TYPE, h);
        class g extends t2 {
          constructor(e3, t3, r3, s2) {
            super(e3, t3), this.oldName = r3, this.type = g.TYPE, this.newName = null != s2 ? s2 : t3.getName();
          }
          run(e3) {
            const t3 = this.getEventWorkspace_().getProcedureMap().get(this.procedure.getId());
            if (!t3) throw new Error("Cannot change the type of a procedure that does not exist in the procedure map");
            if (e3) {
              if (t3.getName() !== this.oldName) return;
              t3.setName(this.newName);
            } else {
              if (t3.getName() !== this.newName) return;
              t3.setName(this.oldName);
            }
          }
          toJson() {
            const e3 = super.toJson();
            return e3.newName = this.newName, e3.oldName = this.oldName, e3;
          }
          static fromJson(e3, t3) {
            const r3 = t3.getProcedureMap().get(e3.procedureId);
            if (!r3) throw new Error("Cannot deserialize procedure rename event because the target procedure does not exist");
            return new g(t3, r3, e3.oldName, e3.newName);
          }
        }
        g.TYPE = "procedure_rename", e2.registry.register(e2.registry.Type.EVENT, g.TYPE, g);
        class m {
          constructor(t3, r3, s2) {
            this.workspace = t3, this.parameters = [], this.returnTypes = null, this.enabled = true, this.shouldFireEvents = false, this.shouldTriggerUpdates = true, this.id = null != s2 ? s2 : e2.utils.idGenerator.genUid(), this.name = r3;
          }
          setName(t3) {
            if (t3 === this.name) return this;
            const r3 = this.name;
            return this.name = t3, this.shouldTriggerUpdates && n(this.workspace), this.shouldFireEvents && e2.Events.fire(new g(this.workspace, this, r3)), this;
          }
          insertParameter(t3, r3) {
            return this.parameters[r3] && this.parameters[r3].getId() === t3.getId() || (this.parameters.splice(r3, 0, t3), t3.setProcedureModel(this), e2.isObservable(t3) && (this.shouldFireEvents ? t3.startPublishing() : t3.stopPublishing()), this.shouldTriggerUpdates && n(this.workspace), this.shouldFireEvents && e2.Events.fire(new p(this.workspace, this, t3, r3))), this;
          }
          deleteParameter(t3) {
            if (!this.parameters[t3]) return this;
            const r3 = this.parameters[t3];
            return this.parameters.splice(t3, 1), this.shouldTriggerUpdates && n(this.workspace), e2.isObservable(r3) && r3.stopPublishing(), this.shouldFireEvents && e2.Events.fire(new h(this.workspace, this, r3, t3)), this;
          }
          setReturnTypes(t3) {
            if (t3 && t3.length) throw new Error("The built-in ProcedureModel does not support typing. You need to implement your own custom ProcedureModel.");
            if (!!t3 == !!this.returnTypes) return this;
            const r3 = this.returnTypes;
            return this.returnTypes = t3, this.shouldTriggerUpdates && n(this.workspace), this.shouldFireEvents && e2.Events.fire(new d(this.workspace, this, r3)), this;
          }
          setEnabled(t3) {
            return t3 === this.enabled || (this.enabled = t3, this.shouldTriggerUpdates && n(this.workspace), this.shouldFireEvents && e2.Events.fire(new l(this.workspace, this))), this;
          }
          startBulkUpdate() {
            this.shouldTriggerUpdates = false;
          }
          endBulkUpdate() {
            this.shouldTriggerUpdates = true, n(this.workspace);
          }
          getId() {
            return this.id;
          }
          getName() {
            return this.name;
          }
          getParameter(e3) {
            return this.parameters[e3];
          }
          getParameters() {
            return [...this.parameters];
          }
          getReturnTypes() {
            return this.returnTypes;
          }
          getEnabled() {
            return this.enabled;
          }
          startPublishing() {
            this.shouldFireEvents = true, e2.Events.fire(new c(this.workspace, this));
            for (const t3 of this.parameters) e2.isObservable(t3) && t3.startPublishing();
          }
          stopPublishing() {
            n(this.workspace), e2.Events.fire(new u(this.workspace, this)), this.shouldFireEvents = false;
            for (const t3 of this.parameters) e2.isObservable(t3) && t3.stopPublishing();
          }
        }
        const _ = e2.common.createBlockDefinitionsFromJsonArray([{ type: "procedures_defnoreturn", message0: "%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2 %3", message1: "%{BKY_PROCEDURES_DEFNORETURN_DO} %1", args0: [{ type: "field_input", name: "NAME", text: "", spellcheck: false }, { type: "field_label", name: "PARAMS", text: "" }, { type: "input_dummy", name: "TOP" }], args1: [{ type: "input_statement", name: "STACK" }], style: "procedure_blocks", helpUrl: "%{BKY_PROCEDURES_DEFNORETURN_HELPURL}", tooltip: "%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}", extensions: ["procedure_def_get_def_mixin", "procedure_def_var_mixin", "procedure_def_update_shape_mixin", "procedure_def_context_menu_mixin", "procedure_def_onchange_mixin", "procedure_def_validator_helper", "procedure_defnoreturn_get_caller_block_mixin", "procedure_defnoreturn_set_comment_helper", "procedure_def_set_no_return_helper"], mutator: "procedure_def_mutator" }, { type: "procedures_callnoreturn", message0: "%1 %2", args0: [{ type: "field_label", name: "NAME", text: "%{BKY_UNNAMED_KEY}" }, { type: "input_dummy", name: "TOPROW" }], nextStatement: null, previousStatement: null, style: "procedure_blocks", helpUrl: "%{BKY_PROCEDURES_CALLNORETURN_HELPURL}", extensions: ["procedure_caller_get_def_mixin", "procedure_caller_var_mixin", "procedure_caller_update_shape_mixin", "procedure_caller_context_menu_mixin", "procedure_caller_onchange_mixin", "procedure_callernoreturn_get_def_block_mixin"], mutator: "procedure_caller_mutator" }, { type: "procedures_defreturn", message0: "%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2 %3", message1: "%{BKY_PROCEDURES_DEFRETURN_DO} %1", message2: "%{BKY_PROCEDURES_DEFRETURN_RETURN} %1", args0: [{ type: "field_input", name: "NAME", text: "", spellcheck: false }, { type: "field_label", name: "PARAMS", text: "" }, { type: "input_dummy", name: "TOP" }], args1: [{ type: "input_statement", name: "STACK" }], args2: [{ type: "input_value", align: "right", name: "RETURN" }], style: "procedure_blocks", helpUrl: "%{BKY_PROCEDURES_DEFRETURN_HELPURL}", tooltip: "%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}", extensions: ["procedure_def_get_def_mixin", "procedure_def_var_mixin", "procedure_def_update_shape_mixin", "procedure_def_context_menu_mixin", "procedure_def_onchange_mixin", "procedure_def_validator_helper", "procedure_defreturn_get_caller_block_mixin", "procedure_defreturn_set_comment_helper", "procedure_def_set_return_helper"], mutator: "procedure_def_mutator" }, { type: "procedures_callreturn", message0: "%1 %2", args0: [{ type: "field_label", name: "NAME", text: "%{BKY_UNNAMED_KEY}" }, { type: "input_dummy", name: "TOPROW" }], output: null, style: "procedure_blocks", helpUrl: "%{BKY_PROCEDURES_CALLRETURN_HELPURL}", extensions: ["procedure_caller_get_def_mixin", "procedure_caller_var_mixin", "procedure_caller_update_shape_mixin", "procedure_caller_context_menu_mixin", "procedure_caller_onchange_mixin", "procedure_callerreturn_get_def_block_mixin"], mutator: "procedure_caller_mutator" }]);
        e2.Extensions.register("procedure_def_get_def_mixin", function() {
          const t3 = { model_: null, getProcedureModel() {
            return this.model_;
          }, isProcedureDef: () => true, getVars: function() {
            return this.getProcedureModel().getParameters().map((e3) => e3.getVariableModel().name);
          }, getVarModels: function() {
            return this.getProcedureModel().getParameters().map((e3) => e3.getVariableModel());
          }, destroy: function() {
            this.workspace.getProcedureMap().delete(this.getProcedureModel().getId());
          } };
          t3.model_ = new m(this.workspace, e2.Procedures.findLegalName(this.getFieldValue("NAME"), this)), e2.Events.disable(), this.workspace.getProcedureMap().add(t3.getProcedureModel()), e2.Events.enable(), this.mixin(t3, true);
        }), e2.Extensions.register("procedure_def_var_mixin", function() {
          this.mixin({ renameVarById: function(e3, t3) {
            const r3 = this.workspace.getVariableById(e3), s2 = this.getProcedureModel(), o2 = s2.getParameters().findIndex((e4) => e4.getVariableModel() === r3);
            if (-1 === o2) return;
            const i2 = this.workspace.getVariableById(t3);
            s2.getParameter(o2).setName(i2.name);
          }, updateVarName: function(e3) {
            this.getProcedureModel().getParameters().some((t3) => t3.getVariableModel() === e3) && this.doProcedureUpdate();
          } }, true);
        });
        const E = { doProcedureUpdate: function() {
          this.setFieldValue(this.getProcedureModel().getName(), "NAME"), this.setEnabled(this.getProcedureModel().getEnabled()), this.updateParameters_(), this.updateMutator_();
        }, updateParameters_: function() {
          const t3 = this.getProcedureModel().getParameters().map((e3) => e3.getName()), r3 = t3.length ? `${e2.Msg.PROCEDURES_BEFORE_PARAMS} ${t3.join(", ")}` : "";
          e2.Events.disable();
          try {
            this.setFieldValue(r3, "PARAMS");
          } finally {
            e2.Events.enable();
          }
        }, updateMutator_: function() {
          const t3 = this.getIcon(e2.icons.MutatorIcon.TYPE);
          if (!(null == t3 ? void 0 : t3.bubbleIsVisible())) return;
          const r3 = this.mutator.getWorkspace();
          for (const e3 of this.getProcedureModel().getParameters()) {
            const t4 = r3.getBlockById(e3.getId());
            t4 && t4.getFieldValue("NAME") !== e3.getName() && t4.setFieldValue(e3.getName(), "NAME");
          }
        }, setStatements_: function(t3) {
          var r3;
          if (this.hasStatements_ !== t3) {
            if (t3) this.appendStatementInput("STACK").appendField(e2.Msg.PROCEDURES_DEFNORETURN_DO), this.getInput("RETURN") && this.moveInputBefore("STACK", "RETURN"), null === (r3 = this.statementConnection_) || void 0 === r3 || r3.call(this, this, "STACK"), this.statementConnection_ = null;
            else {
              const e3 = this.getInput("STACK").connection;
              if (this.statementConnection_ = e3.targetConnection, this.statementConnection_) {
                const t4 = e3.targetBlock();
                t4.unplug(), t4.bumpNeighbours();
              }
              this.removeInput("STACK", true);
            }
            this.hasStatements_ = t3;
          }
        } };
        e2.Extensions.registerMixin("procedure_def_update_shape_mixin", E), e2.Extensions.register("procedure_def_validator_helper", function() {
          const t3 = this.getField("NAME");
          t3.setValue(e2.Procedures.findLegalName("", this)), t3.setValidator(e2.Procedures.rename);
        });
        const f = { hasStatements_: true, mutationToDom: function() {
          const t3 = e2.utils.xml.createElement("mutation"), r3 = this.getProcedureModel().getParameters();
          for (let s2 = 0; s2 < r3.length; s2++) {
            const o2 = e2.utils.xml.createElement("arg"), i2 = r3[s2].getVariableModel();
            o2.setAttribute("name", i2.name), o2.setAttribute("varid", i2.getId()), t3.appendChild(o2);
          }
          return this.hasStatements_ || t3.setAttribute("statements", "false"), t3;
        }, domToMutation: function(e3) {
          for (let t3 = 0; t3 < e3.childNodes.length; t3++) {
            const r3 = e3.childNodes[t3];
            if ("arg" !== r3.nodeName.toLowerCase()) continue;
            const s2 = r3.getAttribute("varid");
            this.getProcedureModel().insertParameter(new a(this.workspace, r3.getAttribute("name"), void 0, s2), t3);
          }
          this.setStatements_("false" !== e3.getAttribute("statements"));
        }, saveExtraState: function(e3) {
          const t3 = /* @__PURE__ */ Object.create(null);
          if (t3.procedureId = this.getProcedureModel().getId(), e3) {
            t3.fullSerialization = true;
            const e4 = this.getProcedureModel().getParameters();
            e4.length && (t3.params = e4.map((e5) => ({ name: e5.getName(), id: e5.getVariableModel().getId(), paramId: e5.getId() })));
          }
          return this.hasStatements_ || (t3.hasStatements = false), t3;
        }, loadExtraState: function(e3) {
          var t3;
          const r3 = this.workspace.getProcedureMap(), s2 = e3.procedureId;
          r3.has(s2) && !e3.fullSerialization && (r3.has(this.model_.getId()) && r3.delete(this.model_.getId()), this.model_ = r3.get(s2));
          const o2 = this.getProcedureModel(), i2 = null !== (t3 = e3.params) && void 0 !== t3 ? t3 : [], n2 = new Set(i2.map((e4) => e4.id)), d2 = o2.getParameters();
          if (e3.fullSerialization) for (let e4 = d2.length - 1; e4 >= 0; e4--) n2.has(d2[e4].getId) || o2.deleteParameter(e4);
          for (let t4 = 0; t4 < i2.length; t4++) {
            const { name: r4, id: s3, paramId: o3 } = e3.params[t4];
            this.getProcedureModel().insertParameter(new a(this.workspace, r4, o3, s3), t4);
          }
          this.doProcedureUpdate(), this.setStatements_(false !== e3.hasStatements);
        }, decompose: function(t3) {
          const r3 = { type: "procedures_mutatorcontainer", inputs: { STACK: {} } };
          let s2 = r3.inputs.STACK;
          for (const e3 of this.getProcedureModel().getParameters()) s2.block = { type: "procedures_mutatorarg", id: e3.getId(), fields: { NAME: e3.getName() }, next: {} }, s2 = s2.block.next;
          const o2 = e2.serialization.blocks.append(r3, t3, { recordUndo: false });
          return "procedures_defreturn" === this.type ? o2.setFieldValue(this.hasStatements_, "STATEMENTS") : o2.removeInput("STATEMENT_INPUT"), o2;
        }, compose: function(e3) {
          this.deleteParamsFromModel_(e3), this.renameParamsInModel_(e3), this.addParamsToModel_(e3);
          const t3 = e3.getFieldValue("STATEMENTS");
          null !== t3 && this.setStatements_("TRUE" === t3);
        }, deleteParamsFromModel_: function(e3) {
          const t3 = new Set(e3.getDescendants().map((e4) => e4.id)), r3 = this.getProcedureModel();
          for (let e4 = r3.getParameters().length - 1; e4 >= 0; e4--) t3.has(r3.getParameter(e4).getId()) || r3.deleteParameter(e4);
        }, renameParamsInModel_: function(e3) {
          const t3 = this.getProcedureModel();
          let r3 = 0, s2 = e3.getInputTargetBlock("STACK");
          for (; s2 && !s2.isInsertionMarker(); ) {
            const e4 = t3.getParameter(r3);
            e4 && e4.getId() === s2.id && e4.getName() !== s2.getFieldValue("NAME") && e4.setName(s2.getFieldValue("NAME")), s2 = s2.nextConnection && s2.nextConnection.targetBlock(), r3++;
          }
        }, addParamsToModel_: function(e3) {
          const t3 = this.getProcedureModel();
          let r3 = 0, s2 = e3.getInputTargetBlock("STACK");
          for (; s2 && !s2.isInsertionMarker(); ) t3.getParameter(r3) && t3.getParameter(r3).getId() === s2.id || t3.insertParameter(new a(this.workspace, s2.getFieldValue("NAME"), s2.id), r3), s2 = s2.nextConnection && s2.nextConnection.targetBlock(), r3++;
        } };
        e2.Extensions.registerMutator("procedure_def_mutator", f, void 0, ["procedures_mutatorarg"]);
        const P = { customContextMenu: function(t3) {
          if (this.isInFlyout) return;
          const r3 = e2.utils.xml.createElement("mutation");
          r3.setAttribute("name", this.getFieldValue("NAME"));
          const s2 = this.getProcedureModel().getParameters();
          for (const t4 of s2) {
            const s3 = e2.utils.xml.createElement("arg");
            s3.setAttribute("name", t4.getName()), r3.appendChild(s3);
          }
          const o2 = e2.utils.xml.createElement("block");
          if (o2.setAttribute("type", this.callType_), o2.appendChild(r3), t3.push({ enabled: true, text: e2.Msg.PROCEDURES_CREATE_DO.replace("%1", this.getFieldValue("NAME")), callback: e2.ContextMenu.callbackFactory(this, o2) }), !this.isCollapsed()) for (const r4 of s2) {
            const s3 = r4.getVariableModel(), o3 = e2.Variables.generateVariableFieldDom(s3), i2 = e2.utils.xml.createElement("block");
            i2.setAttribute("type", "variables_get"), i2.appendChild(o3), t3.push({ enabled: true, text: e2.Msg.VARIABLES_SET_CREATE_GET.replace("%1", s3.name), callback: e2.ContextMenu.callbackFactory(this, i2) });
          }
        } };
        e2.Extensions.registerMixin("procedure_def_context_menu_mixin", P);
        const M = { onchange: function(t3) {
          t3.type === e2.Events.BLOCK_CREATE && t3.blockId === this.id && e2.Events.fire(new c(this.workspace, this.getProcedureModel())), t3.type === e2.Events.BLOCK_CHANGE && t3.blockId === this.id && "disabled" === t3.element && this.getProcedureModel().setEnabled(!t3.newValue);
        } };
        e2.Extensions.registerMixin("procedure_def_onchange_mixin", M), e2.Extensions.register("procedure_defnoreturn_set_comment_helper", function() {
          (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && e2.Msg.PROCEDURES_DEFNORETURN_COMMENT && this.setCommentText(e2.Msg.PROCEDURES_DEFNORETURN_COMMENT);
        }), e2.Extensions.register("procedure_defreturn_set_comment_helper", function() {
          (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && e2.Msg.PROCEDURES_DEFRETURN_COMMENT && this.setCommentText(e2.Msg.PROCEDURES_DEFRETURN_COMMENT);
        }), e2.Extensions.registerMixin("procedure_defnoreturn_get_caller_block_mixin", { callType_: "procedures_callnoreturn" }), e2.Extensions.registerMixin("procedure_defreturn_get_caller_block_mixin", { callType_: "procedures_callreturn" }), e2.Extensions.register("procedure_def_set_no_return_helper", function() {
          this.getProcedureModel().setReturnTypes(null);
        }), e2.Extensions.register("procedure_def_set_return_helper", function() {
          this.getProcedureModel().setReturnTypes([]);
        }), e2.Extensions.register("procedure_caller_get_def_mixin", function() {
          const e3 = { model_: null, prevParams_: [], argsMap_: /* @__PURE__ */ new Map(), getProcedureModel() {
            return this.model_;
          }, findProcedureModel_(e4, t3 = []) {
            const r3 = this.getTargetWorkspace_().getProcedureMap().getProcedures().find((t4) => t4.getName() === e4);
            if (!r3) return null;
            const s2 = r3.getReturnTypes();
            return (this.hasReturn_ ? s2 : !s2) && r3.getParameters().every((e5, r4) => e5.getName() === t3[r4]) ? r3 : null;
          }, getTargetWorkspace_() {
            return this.workspace.isFlyout ? this.workspace.targetWorkspace : this.workspace;
          }, isProcedureDef: () => false, getVars: function() {
            return this.getProcedureModel().getParameters().map((e4) => e4.getVariableModel().name);
          }, getVarModels: function() {
            return this.getProcedureModel().getParameters().map((e4) => e4.getVariableModel());
          } };
          this.mixin(e3, true);
        }), e2.Extensions.register("procedure_caller_var_mixin", function() {
          this.mixin({ updateVarName: function(e3) {
            this.getProcedureModel().getParameters().some((t3) => t3.getVariableModel() === e3) && this.doProcedureUpdate();
          } }, true);
        });
        const T = { previousEnabledState_: true, paramsFromSerializedState_: [], mutationToDom: function() {
          const t3 = e2.utils.xml.createElement("mutation"), r3 = this.getProcedureModel();
          if (!r3) return t3;
          t3.setAttribute("name", r3.getName());
          for (const s2 of r3.getParameters()) {
            const r4 = e2.utils.xml.createElement("arg");
            r4.setAttribute("name", s2.getName()), t3.appendChild(r4);
          }
          return t3;
        }, domToMutation: function(e3) {
          const t3 = e3.getAttribute("name"), r3 = [];
          for (const t4 of e3.childNodes) "arg" === t4.nodeName.toLowerCase() && r3.push(t4.getAttribute("name"));
          this.deserialize_(t3, r3);
        }, saveExtraState: function() {
          const e3 = /* @__PURE__ */ Object.create(null), t3 = this.getProcedureModel();
          return t3 ? (e3.name = t3.getName(), t3.getParameters().length && (e3.params = t3.getParameters().map((e4) => e4.getName())), e3) : (e3.name = this.getFieldValue("NAME"), e3.params = this.paramsFromSerializedState_, e3);
        }, loadExtraState: function(e3) {
          this.deserialize_(e3.name, e3.params || []);
        }, deserialize_: function(e3, t3) {
          this.setFieldValue(e3, "NAME"), this.model_ || (this.model_ = this.findProcedureModel_(e3, t3)), this.getProcedureModel() ? this.initBlockWithProcedureModel_() : this.createArgInputs_(t3), this.paramsFromSerializedState_ = t3;
        } };
        e2.Extensions.registerMutator("procedure_caller_mutator", T);
        const b = { initBlockWithProcedureModel_() {
          this.prevParams_ = [...this.getProcedureModel().getParameters()], this.doProcedureUpdate();
        }, doProcedureUpdate: function() {
          if (!this.getProcedureModel()) return;
          const e3 = this.getProcedureModel().getId();
          this.getTargetWorkspace_().getProcedureMap().has(e3) ? (this.updateName_(), this.updateEnabled_(), this.updateParameters_()) : this.dispose();
        }, updateName_: function() {
          const t3 = this.getProcedureModel().getName();
          this.setFieldValue(t3, "NAME");
          const r3 = this.outputConnection ? e2.Msg.PROCEDURES_CALLRETURN_TOOLTIP : e2.Msg.PROCEDURES_CALLNORETURN_TOOLTIP;
          this.setTooltip(r3.replace("%1", t3));
        }, updateEnabled_: function() {
          this.getProcedureModel().getEnabled() ? this.setEnabled(this.previousEnabledState_) : (this.previousEnabledState_ = this.isEnabled(), this.setEnabled(false));
        }, updateParameters_: function() {
          this.syncArgsMap_(), this.deleteAllArgInputs_(), this.addParametersLabel__(), this.createArgInputs_(), this.reattachBlocks_(), this.prevParams_ = [...this.getProcedureModel().getParameters()];
        }, syncArgsMap_: function() {
          for (const [e3, t3] of this.prevParams_.entries()) {
            const r3 = this.getInputTargetBlock(`ARG${e3}`);
            r3 && this.argsMap_.set(t3.getId(), r3);
          }
        }, updateArgsMap_: function() {
          for (const [e3, t3] of this.getProcedureModel().getParameters().entries()) {
            const r3 = this.getInputTargetBlock(`ARG${e3}`);
            r3 ? this.argsMap_.set(t3.getId(), r3) : this.argsMap_.delete(t3.getId());
          }
        }, deleteAllArgInputs_: function() {
          let e3 = 0;
          for (; this.getInput(`ARG${e3}`); ) this.removeInput(`ARG${e3}`), e3++;
        }, addParametersLabel__: function() {
          const t3 = this.getInput("TOPROW");
          this.getProcedureModel().getParameters().length ? this.getField("WITH") || (t3.appendField(e2.Msg.PROCEDURES_CALL_BEFORE_PARAMS, "WITH"), t3.init()) : this.getField("WITH") && t3.removeField("WITH");
        }, createArgInputs_: function(t3 = null) {
          t3 || (t3 = this.getProcedureModel().getParameters().map((e3) => e3.getName()));
          for (const [r3, s2] of t3.entries()) this.appendValueInput(`ARG${r3}`).appendField(new e2.FieldLabel(s2), `ARGNAME${r3}`).setAlign(e2.Input.Align.RIGHT);
        }, reattachBlocks_: function() {
          const e3 = this.getProcedureModel().getParameters();
          for (const [t3, r3] of e3.entries()) this.argsMap_.has(r3.getId()) && this.getInput(`ARG${t3}`).connection.connect(this.argsMap_.get(r3.getId()).outputConnection);
        }, renameProcedure: function(t3, r3) {
          if (e2.Names.equals(t3, this.getFieldValue("NAME"))) {
            this.setFieldValue(r3, "NAME");
            const t4 = this.outputConnection ? e2.Msg.PROCEDURES_CALLRETURN_TOOLTIP : e2.Msg.PROCEDURES_CALLNORETURN_TOOLTIP;
            this.setTooltip(t4.replace("%1", r3));
          }
        } };
        e2.Extensions.registerMixin("procedure_caller_update_shape_mixin", b);
        const x = { onchange: function(t3) {
          if (this.disposed || this.workspace.isFlyout) return;
          if (t3.type === e2.Events.BLOCK_MOVE && this.updateArgsMap_(true), t3.type !== e2.Events.FINISHED_LOADING && !this.eventIsCreatingThisBlockDuringPaste_(t3)) return;
          if (this.getProcedureModel()) return;
          const r3 = this.getFieldValue("NAME");
          let s2 = e2.Procedures.getDefinition(r3, this.workspace);
          this.defMatches_(s2) || (s2 = null), s2 || (e2.Events.setGroup(t3.group), this.model_ = this.createDef_(this.getFieldValue("NAME"), this.paramsFromSerializedState_), e2.Events.setGroup(false)), this.getProcedureModel() || (this.model_ = this.findProcedureModel_(this.getFieldValue("NAME"), this.paramsFromSerializedState_)), this.initBlockWithProcedureModel_();
        }, eventIsCreatingThisBlockDuringPaste_(t3) {
          return t3.type === e2.Events.BLOCK_CREATE && (t3.blockId === this.id || -1 !== t3.ids.indexOf(this.id)) && t3.recordUndo;
        }, defMatches_(e3) {
          return e3 && e3.type === this.defType_ && JSON.stringify(e3.getVars()) === JSON.stringify(this.paramsFromSerializedState_);
        }, createDef_(t3, r3 = []) {
          const s2 = this.getRelativeToSurfaceXY(), o2 = e2.Procedures.findLegalName(t3, this);
          this.renameProcedure(t3, o2);
          const i2 = { type: this.defType_, x: s2.x + e2.config.snapRadius * (this.RTL ? -1 : 1), y: s2.y + 2 * e2.config.snapRadius, extraState: { params: r3.map((e3) => ({ name: e3 })) }, fields: { NAME: o2 } };
          return e2.serialization.blocks.append(i2, this.getTargetWorkspace_(), { recordUndo: true }).getProcedureModel();
        } };
        e2.Extensions.registerMixin("procedure_caller_onchange_mixin", x);
        const N = { customContextMenu: function(t3) {
          if (!this.workspace.isMovable()) return;
          const r3 = this.getFieldValue("NAME"), s2 = this.workspace;
          t3.push({ enabled: true, text: e2.Msg.PROCEDURES_HIGHLIGHT_DEF, callback: function() {
            const t4 = e2.Procedures.getDefinition(r3, s2);
            t4 && t4 instanceof e2.BlockSvg && (s2.centerOnBlock(t4.id), t4.select());
          } });
        } };
        function y(e3) {
          return void 0 !== e3.getProcedureModel && void 0 !== e3.doProcedureUpdate && void 0 !== e3.isProcedureDef;
        }
        function R() {
          delete e2.Blocks.procedures_defnoreturn, delete e2.Blocks.procedures_callnoreturn, delete e2.Blocks.procedures_defreturn, delete e2.Blocks.procedures_callreturn;
        }
        function w() {
          e2.serialization.registry.unregister("procedures"), e2.serialization.registry.register("procedures", new e2.serialization.procedures.ProcedureSerializer(m, a));
        }
        e2.Extensions.registerMixin("procedure_caller_context_menu_mixin", N), e2.Extensions.registerMixin("procedure_callernoreturn_get_def_block_mixin", { hasReturn_: false, defType_: "procedures_defnoreturn" }), e2.Extensions.registerMixin("procedure_callerreturn_get_def_block_mixin", { hasReturn_: true, defType_: "procedures_defreturn" });
      })(), o;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@blockly/block-shareable-procedures/dist/index.js:
  (*! For license information please see index.js.LICENSE.txt *)
*/
//# sourceMappingURL=@blockly_block-shareable-procedures.js.map

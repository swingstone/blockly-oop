{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-shareable-procedures/webpack/universalModuleDefinition","webpack://@blockly/block-shareable-procedures/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-shareable-procedures/webpack/bootstrap","webpack://@blockly/block-shareable-procedures/webpack/runtime/define property getters","webpack://@blockly/block-shareable-procedures/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-shareable-procedures/webpack/runtime/make namespace object","webpack://@blockly/block-shareable-procedures/./src/events_procedure_base.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_base.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_rename.ts","webpack://@blockly/block-shareable-procedures/./src/update_procedures.ts","webpack://@blockly/block-shareable-procedures/./src/observable_parameter_model.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_change_return.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_create.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_delete.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_enable.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_create.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_delete.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_rename.ts","webpack://@blockly/block-shareable-procedures/./src/observable_procedure_model.ts","webpack://@blockly/block-shareable-procedures/./src/blocks.ts","webpack://@blockly/block-shareable-procedures/./src/i_procedure_block.ts","webpack://@blockly/block-shareable-procedures/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The base event for an event associated with a procedure.\n */\nexport abstract class ProcedureBase extends Blockly.Events.Abstract {\n  static readonly TYPE: string = 'procedure_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureBase.TYPE;\n\n  isBlank = false;\n\n  /**\n   * Constructs the base procedure event.\n   *\n   * @param workspace The workspace the procedure model exists in.\n   * @param procedure The procedure model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    readonly procedure: Blockly.procedures.IProcedureModel,\n  ) {\n    super();\n    this.workspaceId = workspace.id;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureBaseJson {\n    const json = super.toJson() as ProcedureBaseJson;\n    json['procedureId'] = this.procedure.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureBaseJson extends Blockly.Events.AbstractEventJson {\n  procedureId: string;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * The base event for an event associated with a procedure parameter.\n */\nexport abstract class ProcedureParameterBase extends ProcedureBase {\n  static readonly TYPE: string = 'procedure_parameter_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterBase.TYPE;\n\n  /**\n   * Constructs the procedure parameter base event.\n   *\n   * @param workspace The workspace the parameter model exists in.\n   * @param procedure The procedure model the parameter model belongs to.\n   * @param parameter The parameter model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly parameter: Blockly.procedures.IParameterModel,\n  ) {\n    super(workspace, procedure);\n    this.recordUndo = false;\n  }\n\n  /**\n   * Finds the parameter with the given ID in the procedure model with the given\n   * ID, if both things exist.\n   *\n   * @param workspace The workspace to search for the parameter.\n   * @param procedureId The ID of the procedure model to search for\n   *     the parameter.\n   * @param paramId The ID of the parameter to search for.\n   * @returns The parameter model that was found.\n   * @internal\n   */\n  static findMatchingParameter(\n    workspace: Blockly.Workspace,\n    procedureId: string,\n    paramId: string,\n  ): ProcedureParameterPair {\n    const procedure = workspace.getProcedureMap().get(procedureId);\n    if (!procedure) return {procedure: undefined, parameter: undefined};\n    const parameter = procedure\n      .getParameters()\n      .find((p) => p.getId() === paramId);\n    if (!parameter) return {procedure, parameter: undefined};\n    return {procedure, parameter};\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterBaseJson {\n    const json = super.toJson() as ProcedureParameterBaseJson;\n    json['parameterId'] = this.parameter.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureParameterPair {\n  procedure?: Blockly.procedures.IProcedureModel;\n  parameter?: Blockly.procedures.IParameterModel;\n}\n\nexport interface ProcedureParameterBaseJson extends ProcedureBaseJson {\n  parameterId: string;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a procedure parameter was renamed.\n */\nexport class ProcedureParameterRename extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterRename.TYPE;\n\n  /** The new name of the procedure parameter. */\n  private readonly newName: string;\n\n  /** The new ID the backing variable for the parameter. */\n  private readonly newVarId: string;\n\n  /**\n   * Constructs the procedure parameter rename event.\n   *\n   * @param workspace The workpace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model this event is associated with.\n   * @param oldName The old name of the procedure parameter.\n   * @param newName The (optional) new name of the procedure parameter. If not\n   *     provided, the parameter model will be inspected to see what its current\n   *     name is.\n   * @param newVarId The (optional) new id of the procedure parameter's backing\n   *     variable. If not provided, the parameter model will be inspected to\n   *     see what its current name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly oldName: string,\n    newName?: string,\n    newVarId?: string,\n  ) {\n    super(workspace, procedure, parameter);\n\n    this.newName = newName ?? parameter.getName();\n    this.newVarId = newVarId ?? parameter.getVariableModel().getId();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const {parameter} = ProcedureParameterBase.findMatchingParameter(\n      this.getEventWorkspace_(),\n      this.procedure.getId(),\n      this.parameter.getId(),\n    );\n    if (forward) {\n      if (parameter.getName() !== this.oldName) return;\n      (parameter as ObservableParameterModel).setName(\n        this.newName,\n        this.newVarId,\n      );\n    } else {\n      if (parameter.getName() !== this.newName) return;\n      parameter.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterRenameJson {\n    const json = super.toJson() as ProcedureParameterRenameJson;\n    json['newName'] = this.newName;\n    json['newVarId'] = this.newVarId;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterRename {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterRename(\n      workspace,\n      procedure,\n      parameter as ObservableParameterModel,\n      json['oldName'],\n      json['newName'],\n      json['newVarId'],\n    );\n  }\n}\n\nexport interface ProcedureParameterRenameJson\n  extends ProcedureParameterBaseJson {\n  oldName: string;\n  newName: string;\n  newVarId: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterRename.TYPE,\n  ProcedureParameterRename,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Calls the `doProcedureUpdate` method on all blocks which implement it.\n *\n * @param workspace The workspace within which to trigger block updates.\n * @internal\n */\nexport function triggerProceduresUpdate(workspace: Blockly.Workspace) {\n  if (workspace.isClearing) return;\n  for (const block of workspace.getAllBlocks(false)) {\n    if (Blockly.procedures.isProcedureBlock(block)) {\n      block.doProcedureUpdate();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureParameterRename} from './events_procedure_parameter_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure parameter. */\nexport class ObservableParameterModel\n  implements Blockly.procedures.IParameterModel\n{\n  private id: string;\n  private variable: Blockly.VariableModel;\n  private shouldFireEvents = false;\n  private procedureModel: Blockly.procedures.IProcedureModel | null = null;\n\n  /**\n   * Constructor for the procedure parameter.\n   *\n   * @param workspace The workspace this parameter model exists in.\n   * @param name The name of this parameter.\n   * @param id The optional unique language-neutral ID of the parameter.\n   * @param varId The optional ID of the variable this parameter should be\n   *     associated with.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n    varId?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.variable = this.createBackingVariable(name, varId);\n  }\n\n  /**\n   * Sets the name of this parameter to the given name.\n   *\n   * @param name The string to set the name to.\n   * @param id The optional ID the backing variable should have.\n   * @returns This parameter model.\n   */\n  setName(name: string, id?: string): this {\n    if (name === this.variable.name) return this;\n    const oldName = this.variable.name;\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', id);\n    triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterRename(\n          this.workspace,\n          this.procedureModel,\n          this,\n          oldName,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Creates a backing variable in a way that is subclassable.\n   *\n   * @param name The string to set set the variable to.\n   * @param varId The optional ID the backing variable should have.\n   * @returns The created variable model.\n   */\n  protected createBackingVariable(\n    name: string,\n    varId?: string,\n  ): Blockly.VariableModel {\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', varId);\n    return this.variable;\n  }\n\n  /**\n   * Unimplemented. The built-in ParameterModel does not support typing.\n   * If you want your procedure blocks to have typed parameters, you need to\n   * implement your own ParameterModel.\n   *\n   * @param types The types to set this parameter to.\n   * @throws Throws for the ObservableParameterModel specifically because this\n   *     method is unimplemented.\n   */\n  setTypes(types: string[]): this {\n    throw new Error(\n      'The built-in ParameterModel does not support typing. You need to ' +\n        'implement your own custom ParameterModel.',\n    );\n  }\n\n  /**\n   * @returns the name of this parameter.\n   */\n  getName(): string {\n    return this.variable.name;\n  }\n\n  /**\n   * @returns the types of this parameter.\n   */\n  getTypes(): string[] {\n    return [];\n  }\n\n  /**\n   * Returns the unique language-neutral ID for the parameter. This represents\n   * the identity of the variable model which does not change over time.\n   *\n   * @returns The unique language-neutral ID for the parameter.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns the variable model associated with the parameter model.\n   */\n  getVariableModel(): Blockly.VariableModel {\n    return this.variable;\n  }\n\n  /**\n   * Tells the parameter model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n  }\n\n  /**\n   * Tells the parameter model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    this.shouldFireEvents = false;\n  }\n\n  /**\n   * Sets the procedure model this parameter is a part of.\n   *\n   * @param model The procedure model this parameter is a part of.\n   * @returns This parameter model.\n   */\n  setProcedureModel(model: Blockly.procedures.IProcedureModel): this {\n    this.procedureModel = model;\n    return this;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure's return type/status has changed.\n */\nexport class ProcedureChangeReturn extends ProcedureBase {\n  static readonly TYPE = 'procedure_change';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureChangeReturn.TYPE;\n\n  /** The new type(s) the procedure's return has been set to. */\n  private newTypes: string[] | null;\n\n  /**\n   * Constructs the procedure change event.\n   *\n   * @param workpace The workspace this change event is associated with.\n   * @param procedure The model this change event is associated with.\n   * @param oldTypes The type(s) the procedure's return was set to before it\n   *     changed.\n   */\n  constructor(\n    workpace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldTypes: string[] | null,\n  ) {\n    super(workpace, procedure);\n\n    this.newTypes = procedure.getReturnTypes();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setReturnTypes(this.newTypes);\n    } else {\n      procedureModel.setReturnTypes(this.oldTypes);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureChangeReturnJson {\n    const json = super.toJson() as ProcedureChangeReturnJson;\n    json['oldTypes'] = this.oldTypes;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure change event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure change return event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureChangeReturnJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureChangeReturn {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure change return event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureChangeReturn(workspace, model, json['oldTypes']);\n  }\n}\n\nexport interface ProcedureChangeReturnJson extends ProcedureBaseJson {\n  oldTypes: string[] | null;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureChangeReturn.TYPE,\n  ProcedureChangeReturn,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\n/**\n * Notifies listeners that a procedure data model has been created.\n */\nexport class ProcedureCreate extends ProcedureBase {\n  static readonly TYPE = 'procedure_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureCreate.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    } else {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureCreateJson {\n    const json = super.toJson() as ProcedureCreateJson;\n    json['procedure'] = Blockly.serialization.procedures.saveProcedure(\n      this.procedure,\n    );\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureCreate {\n    return new ProcedureCreate(\n      workspace,\n      Blockly.serialization.procedures.loadProcedure(\n        ObservableProcedureModel,\n        ObservableParameterModel,\n        json['procedure'],\n        workspace,\n      ),\n    );\n  }\n}\n\nexport interface ProcedureCreateJson extends ProcedureBaseJson {\n  procedure: Blockly.serialization.procedures.State;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureCreate.TYPE,\n  ProcedureCreate,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure data model has been deleted.\n */\nexport class ProcedureDelete extends ProcedureBase {\n  static readonly TYPE = 'procedure_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureDelete.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    } else {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureDeleteJson {\n    return super.toJson() as ProcedureDeleteJson;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureDelete {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure delete event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureDelete(workspace, model);\n  }\n}\n\nexport type ProcedureDeleteJson = ProcedureBaseJson;\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureDelete.TYPE,\n  ProcedureDelete,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that the procedure data model has been enabled or\n * disabled.\n */\nexport class ProcedureEnable extends ProcedureBase {\n  static readonly TYPE = 'procedure_enable';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureEnable.TYPE;\n\n  private oldState: boolean;\n  private newState: boolean;\n\n  /**\n   * Constructs the procedure enable event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param newState The (optional) new enabled state of the procedure model.\n   *     If not provided, the procedure model will be inspected to determine\n   *     its current state.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    newState?: boolean,\n  ) {\n    super(workspace, procedure);\n\n    if (newState === undefined) {\n      this.oldState = !procedure.getEnabled();\n      this.newState = procedure.getEnabled();\n    } else {\n      this.oldState = !newState;\n      this.newState = newState;\n    }\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the enabled state of a procedure that does not ' +\n          'exist in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setEnabled(this.newState);\n    } else {\n      procedureModel.setEnabled(this.oldState);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureEnableJson {\n    const json = super.toJson() as ProcedureEnableJson;\n    json['newState'] = this.newState;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure enable event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure enable event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureEnableJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureEnable {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure enable event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureEnable(workspace, model, json['newState']);\n  }\n}\n\nexport interface ProcedureEnableJson extends ProcedureBaseJson {\n  newState: boolean;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureEnable.TYPE,\n  ProcedureEnable,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a parameter has been added to a procedure model.\n */\nexport class ProcedureParameterCreate extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterCreate.TYPE;\n\n  parameter: ObservableParameterModel;\n\n  /**\n   * Constructs the procedure parameter create event.js.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just added to the procedure.\n   * @param index The index the parameter was inserted at.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.insertParameter(this.parameter, this.index);\n    } else {\n      procedureModel.deleteParameter(this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterCreateJson {\n    const json = super.toJson() as ProcedureParameterCreateJson;\n    json['name'] = this.parameter.getName();\n    json['id'] = this.parameter.getId();\n    json['varId'] = this.parameter.getVariableModel().getId();\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterCreate {\n    const procedure = workspace.getProcedureMap().get(json['procedureId']);\n    if (!procedure) {\n      throw new Error(\n        'Cannot deserialize parameter create event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureParameterCreate(\n      workspace,\n      procedure,\n      new ObservableParameterModel(\n        workspace,\n        json['name'],\n        json['id'],\n        json['varId'],\n      ),\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterCreateJson\n  extends ProcedureParameterBaseJson {\n  parameter: Blockly.serialization.procedures.ParameterState;\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterCreate.TYPE,\n  ProcedureParameterCreate,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\n\n/**\n * Notifies listeners that a parameter has been removed from a procedure.\n */\nexport class ProcedureParameterDelete extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterDelete.TYPE;\n\n  /**\n   * Constructs the procedure parameter delete event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just removed from the\n   *     procedure.\n   * @param index The index the parameter was at before it was removed.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: Blockly.procedures.IParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.deleteParameter(this.index);\n    } else {\n      procedureModel.insertParameter(this.parameter, this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterDeleteJson {\n    const json = super.toJson() as ProcedureParameterDeleteJson;\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterDelete {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterDelete(\n      workspace,\n      procedure,\n      parameter,\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterDeleteJson\n  extends ProcedureParameterBaseJson {\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterDelete.TYPE,\n  ProcedureParameterDelete,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/** Notifies listeners that a procedure model has been renamed. */\nexport class ProcedureRename extends ProcedureBase {\n  static readonly TYPE = 'procedure_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureRename.TYPE;\n\n  private newName: string;\n\n  /**\n   * Constructs the procedure rename event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param oldName The old name of the procedure model.\n   * @param newName The (optional) new name of the procedure. If not provided,\n   *     the procedure model will be inspected to see what its current\n   *     name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldName: string,\n    newName?: string,\n  ) {\n    super(workspace, procedure);\n\n    this.newName = newName ?? procedure.getName();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      if (procedureModel.getName() !== this.oldName) return;\n      procedureModel.setName(this.newName);\n    } else {\n      if (procedureModel.getName() !== this.newName) return;\n      procedureModel.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureRenameJson {\n    const json = super.toJson() as ProcedureRenameJson;\n    json['newName'] = this.newName;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureRename {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure rename event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureRename(\n      workspace,\n      model,\n      json['oldName'],\n      json['newName'],\n    );\n  }\n}\n\nexport interface ProcedureRenameJson extends ProcedureBaseJson {\n  oldName: string;\n  newName: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureRename.TYPE,\n  ProcedureRename,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ProcedureChangeReturn} from './events_procedure_change_return';\nimport {ProcedureCreate} from './events_procedure_create';\nimport {ProcedureDelete} from './events_procedure_delete';\nimport {ProcedureEnable} from './events_procedure_enable';\nimport {ProcedureParameterCreate} from './events_procedure_parameter_create';\nimport {ProcedureParameterDelete} from './events_procedure_parameter_delete';\nimport {ProcedureRename} from './events_procedure_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure signature. */\nexport class ObservableProcedureModel\n  implements Blockly.procedures.IProcedureModel\n{\n  private id: string;\n  private name: string;\n  private parameters: ObservableParameterModel[] = [];\n  private returnTypes: string[] | null = null;\n  private enabled = true;\n  private shouldFireEvents = false;\n  private shouldTriggerUpdates = true;\n\n  /**\n   * Constructor for the procedure model.\n   *\n   * @param workspace The workspace the procedure model is associated with.\n   * @param name The name of the new procedure.\n   * @param id The (optional) unique language-neutral ID for the procedure.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.name = name;\n  }\n\n  /**\n   * Sets the human-readable name of the procedure.\n   *\n   * @param name The human-readable name of the procedure.\n   * @returns This procedure model.\n   */\n  setName(name: string): this {\n    if (name === this.name) return this;\n    const oldName = this.name;\n    this.name = name;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureRename(this.workspace, this, oldName));\n    }\n    return this;\n  }\n\n  /**\n   * Inserts a parameter into the list of parameters.\n   * To move a parameter, first delete it, and then re-insert.\n   *\n   * @param parameterModel The parameter model to insert.\n   * @param index The index to insert it at.\n   * @returns This procedure model.\n   */\n  insertParameter(\n    parameterModel: ObservableParameterModel,\n    index: number,\n  ): this {\n    if (\n      this.parameters[index] &&\n      this.parameters[index].getId() === parameterModel.getId()\n    ) {\n      return this;\n    }\n\n    this.parameters.splice(index, 0, parameterModel);\n    parameterModel.setProcedureModel(this);\n    if (Blockly.isObservable(parameterModel)) {\n      if (this.shouldFireEvents) {\n        parameterModel.startPublishing();\n      } else {\n        parameterModel.stopPublishing();\n      }\n    }\n\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterCreate(\n          this.workspace,\n          this,\n          parameterModel,\n          index,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Removes the parameter at the given index from the parameter list.\n   *\n   * @param index The index of the parameter to remove.\n   * @returns This procedure model.\n   */\n  deleteParameter(index: number): this {\n    if (!this.parameters[index]) return this;\n    const oldParam = this.parameters[index];\n\n    this.parameters.splice(index, 1);\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (Blockly.isObservable(oldParam)) {\n      oldParam.stopPublishing();\n    }\n\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterDelete(this.workspace, this, oldParam, index),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether the procedure has a return value (empty array) or no return\n   * value (null).\n   * This procedure model does not support procedures that have actual\n   * return types (i.e. non-empty arrays, e.g. ['number']).\n   *\n   * @param types Used to set whether this procedure has a return value\n   *     (empty array) or no return value (null).\n   * @returns This procedure model.\n   */\n  setReturnTypes(types: string[] | null): this {\n    if (types && types.length) {\n      throw new Error(\n        'The built-in ProcedureModel does not support typing. You need to ' +\n          'implement your own custom ProcedureModel.',\n      );\n    }\n    // Either they're both an empty array, or both null. Noop either way.\n    if (!!types === !!this.returnTypes) return this;\n    const oldReturnTypes = this.returnTypes;\n    this.returnTypes = types;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureChangeReturn(this.workspace, this, oldReturnTypes),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether this procedure is enabled/disabled. If a procedure is disabled\n   * all procedure caller blocks should be disabled as well.\n   *\n   * @param enabled Whether this procedure is enabled/disabled.\n   * @returns This procedure model.\n   */\n  setEnabled(enabled: boolean): this {\n    if (enabled === this.enabled) return this;\n    this.enabled = enabled;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureEnable(this.workspace, this));\n    }\n    return this;\n  }\n\n  /**\n   * Disables triggering updates to procedure blocks until the endBulkUpdate\n   * is called.\n   *\n   * @internal\n   */\n  startBulkUpdate() {\n    this.shouldTriggerUpdates = false;\n  }\n\n  /**\n   * Triggers an update to procedure blocks. Should be used with\n   * startBulkUpdate.\n   *\n   * @internal\n   */\n  endBulkUpdate() {\n    this.shouldTriggerUpdates = true;\n    triggerProceduresUpdate(this.workspace);\n  }\n\n  /**\n   * @returns The unique language-neutral ID for the procedure.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns The human-readable name of the procedure\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * @param index The index of the parameter to return.\n   * @returns the parameter at the given index in the parameter list.\n   */\n  getParameter(index: number): Blockly.procedures.IParameterModel {\n    return this.parameters[index];\n  }\n\n  /**\n   * @returns an array of all of the parameters in the parameter list.\n   */\n  getParameters(): Blockly.procedures.IParameterModel[] {\n    return [...this.parameters];\n  }\n\n  /**\n   * Returns the return type of the procedure.\n   * Null represents a procedure that does not return a value.\n   *\n   * @returns the return type of the procedure.\n   */\n  getReturnTypes(): string[] | null {\n    return this.returnTypes;\n  }\n\n  /**\n   * Returns whether the procedure is enabled/disabled. If a procedure is\n   * disabled, all procedure caller blocks should be disabled as well.\n   *\n   * @returns Returns whether the procedure is enabled/disabled.\n   */\n  getEnabled(): boolean {\n    return this.enabled;\n  }\n\n  /**\n   * Tells the procedure model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n    Blockly.Events.fire(new ProcedureCreate(this.workspace, this));\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.startPublishing();\n    }\n  }\n\n  /**\n   * Tells the procedure model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    triggerProceduresUpdate(this.workspace);\n    Blockly.Events.fire(new ProcedureDelete(this.workspace, this));\n    this.shouldFireEvents = false;\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.stopPublishing();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableProcedureModel} from './observable_procedure_model';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {IProcedureBlock} from './i_procedure_block';\nimport {ProcedureCreate} from './events_procedure_create';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A dictionary of the block definitions provided by this module.\n *\n * @type {!Object<string, Object>}\n */\nexport const blocks = Blockly.common.createBlockDefinitionsFromJsonArray([\n  {\n    type: 'procedures_defnoreturn',\n    message0: '%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFNORETURN_DO} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFNORETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defnoreturn_get_caller_block_mixin',\n      'procedure_defnoreturn_set_comment_helper',\n      'procedure_def_set_no_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callnoreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    nextStatement: null,\n    previousStatement: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLNORETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callernoreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n  {\n    type: 'procedures_defreturn',\n    message0: '%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFRETURN_DO} %1',\n    message2: '%{BKY_PROCEDURES_DEFRETURN_RETURN} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    args2: [\n      {\n        type: 'input_value',\n        align: 'right',\n        name: 'RETURN',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFRETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defreturn_get_caller_block_mixin',\n      'procedure_defreturn_set_comment_helper',\n      'procedure_def_set_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    output: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLRETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callerreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n]);\n\nconst procedureDefGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    /**\n     * Returns the data model for this procedure block.\n     *\n     * @returns The data model for this procedure\n     *     block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns True because this is a procedure definition block.\n     */\n    isProcedureDef() {\n      return true;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n\n    /**\n     * Disposes of the data model for this procedure block when the block is\n     * disposed.\n     */\n    destroy: function () {\n      this.workspace.getProcedureMap().delete(this.getProcedureModel().getId());\n    },\n  };\n\n  mixin.model_ = new ObservableProcedureModel(\n    this.workspace,\n    Blockly.Procedures.findLegalName(this.getFieldValue('NAME'), this),\n  );\n\n  // Events cannot be fired from instantiation when deserializing or dragging\n  // from the flyout. So make this consistent and never fire from instantiation.\n  Blockly.Events.disable();\n  this.workspace.getProcedureMap().add(mixin.getProcedureModel());\n  Blockly.Events.enable();\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_def_get_def_mixin',\n  procedureDefGetDefMixin,\n);\n\nconst procedureDefVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming.\n     * If the ID matches one of this block's variables, rename it.\n     *\n     * @param oldId ID of variable to rename.\n     * @param newId ID of new variable.  May be the same as oldId, but\n     *     with an updated name.  Guaranteed to be the same type as the old\n     *     variable.\n     * @override\n     * @this {Blockly.Block}\n     */\n    renameVarById: function (oldId, newId) {\n      const oldVar = this.workspace.getVariableById(oldId);\n      const model = this.getProcedureModel();\n      const index = model\n        .getParameters()\n        .findIndex((p) => p.getVariableModel() === oldVar);\n      if (index === -1) return; // Not found.\n      const newVar = this.workspace.getVariableById(newId);\n      const oldParam = model.getParameter(index);\n      oldParam.setName(newVar.name);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register('procedure_def_var_mixin', procedureDefVarMixin);\n\nconst procedureDefUpdateShapeMixin = {\n  /**\n   * Updates the block to reflect the state of the procedure model.\n   */\n  doProcedureUpdate: function () {\n    this.setFieldValue(this.getProcedureModel().getName(), 'NAME');\n    this.setEnabled(this.getProcedureModel().getEnabled());\n    this.updateParameters_();\n    this.updateMutator_();\n  },\n\n  /**\n   * Updates the parameters field to reflect the parameters in the procedure\n   * model.\n   */\n  updateParameters_: function () {\n    const params = this.getProcedureModel()\n      .getParameters()\n      .map((p) => p.getName());\n    const paramString = params.length\n      ? `${Blockly.Msg['PROCEDURES_BEFORE_PARAMS']} ${params.join(', ')}`\n      : '';\n\n    // The field is deterministic based on other events, no need to fire.\n    Blockly.Events.disable();\n    try {\n      this.setFieldValue(paramString, 'PARAMS');\n    } finally {\n      Blockly.Events.enable();\n    }\n  },\n\n  /**\n   * Updates the parameter blocks in the mutator (if it is open) to reflect\n   * the state of the procedure model.\n   */\n  updateMutator_: function () {\n    const mutator = this.getIcon(Blockly.icons.MutatorIcon.TYPE);\n    if (!mutator?.bubbleIsVisible()) return;\n\n    const mutatorWorkspace = this.mutator.getWorkspace();\n    for (const p of this.getProcedureModel().getParameters()) {\n      const block = mutatorWorkspace.getBlockById(p.getId());\n      if (!block) continue; // Should not happen.\n      if (block.getFieldValue('NAME') !== p.getName()) {\n        block.setFieldValue(p.getName(), 'NAME');\n      }\n    }\n  },\n\n  /**\n   * Add or remove the statement block from this function definition.\n   *\n   * @param hasStatements True if a statement block is needed.\n   * @this {Blockly.Block}\n   */\n  setStatements_: function (hasStatements) {\n    if (this.hasStatements_ === hasStatements) {\n      return;\n    }\n    if (hasStatements) {\n      this.appendStatementInput('STACK').appendField(\n        Blockly.Msg['PROCEDURES_DEFNORETURN_DO'],\n      );\n      if (this.getInput('RETURN')) {\n        this.moveInputBefore('STACK', 'RETURN');\n      }\n      // Restore the stack, if one was saved.\n      this.statementConnection_?.(this, 'STACK');\n      this.statementConnection_ = null;\n    } else {\n      // Save the stack, then disconnect it.\n      const stackConnection = this.getInput('STACK').connection;\n      this.statementConnection_ = stackConnection.targetConnection;\n      if (this.statementConnection_) {\n        const stackBlock = stackConnection.targetBlock();\n        stackBlock.unplug();\n        stackBlock.bumpNeighbours();\n      }\n      this.removeInput('STACK', true);\n    }\n    this.hasStatements_ = hasStatements;\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_update_shape_mixin',\n  procedureDefUpdateShapeMixin,\n);\n\nconst procedureDefValidatorHelper = function () {\n  const nameField = this.getField('NAME');\n  nameField.setValue(Blockly.Procedures.findLegalName('', this));\n  nameField.setValidator(Blockly.Procedures.rename);\n};\nBlockly.Extensions.register(\n  'procedure_def_validator_helper',\n  procedureDefValidatorHelper,\n);\n\nconst procedureDefMutator = {\n  hasStatements_: true,\n\n  /**\n   * Create XML to represent the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const params = this.getProcedureModel().getParameters();\n    for (let i = 0; i < params.length; i++) {\n      const parameter = Blockly.utils.xml.createElement('arg');\n      const varModel = params[i].getVariableModel();\n      parameter.setAttribute('name', varModel.name);\n      parameter.setAttribute('varid', varModel.getId());\n      container.appendChild(parameter);\n    }\n\n    // Save whether the statement input is visible.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    for (let i = 0; i < xmlElement.childNodes.length; i++) {\n      const node = xmlElement.childNodes[i];\n      if (node.nodeName.toLowerCase() !== 'arg') continue;\n      const varId = node.getAttribute('varid');\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(\n          this.workspace,\n          node.getAttribute('name'),\n          undefined,\n          varId,\n        ),\n        i,\n      );\n    }\n    this.setStatements_(xmlElement.getAttribute('statements') !== 'false');\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @param doFullSerialization Tells the block if it should serialize\n   *     its entire state (including data stored in the backing procedure\n   *     model). Used for copy-paste.\n   * @returns The state of this block, eg the parameters and statements.\n   */\n  saveExtraState: function (doFullSerialization) {\n    const state = Object.create(null);\n    state['procedureId'] = this.getProcedureModel().getId();\n\n    if (doFullSerialization) {\n      state['fullSerialization'] = true;\n      const params = this.getProcedureModel().getParameters();\n      if (params.length) {\n        state['params'] = params.map((p) => {\n          return {\n            name: p.getName(),\n            id: p.getVariableModel().getId(),\n            // Ideally this would be id, and the other would be varId,\n            // but backwards compatibility :/\n            paramId: p.getId(),\n          };\n        });\n      }\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function (state) {\n    const map = this.workspace.getProcedureMap();\n\n    const procedureId = state['procedureId'];\n    if (map.has(procedureId) && !state['fullSerialization']) {\n      if (map.has(this.model_.getId())) {\n        map.delete(this.model_.getId());\n      }\n      this.model_ = map.get(procedureId);\n    }\n\n    const model = this.getProcedureModel();\n    const newParams = state['params'] ?? [];\n    const newIds = new Set(newParams.map((p) => p.id));\n    const currParams = model.getParameters();\n    if (state['fullSerialization']) {\n      for (let i = currParams.length - 1; i >= 0; i--) {\n        if (!newIds.has(currParams[i].getId)) {\n          model.deleteParameter(i);\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i++) {\n      const {name, id, paramId} = state['params'][i];\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(this.workspace, name, paramId, id),\n        i,\n      );\n    }\n\n    this.doProcedureUpdate();\n    this.setStatements_(state['hasStatements'] === false ? false : true);\n  },\n\n  /**\n   * Populate the mutator's dialog with this block's components.\n   *\n   * @param workspace Blockly.Mutator's workspace.\n   * @returns Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  decompose: function (workspace) {\n    const containerBlockDef = {\n      type: 'procedures_mutatorcontainer',\n      inputs: {\n        STACK: {},\n      },\n    };\n\n    let connDef = containerBlockDef['inputs']['STACK'];\n    for (const param of this.getProcedureModel().getParameters()) {\n      connDef['block'] = {\n        type: 'procedures_mutatorarg',\n        id: param.getId(),\n        fields: {\n          NAME: param.getName(),\n        },\n        next: {},\n      };\n      connDef = connDef['block']['next'];\n    }\n\n    const containerBlock = Blockly.serialization.blocks.append(\n      containerBlockDef as unknown as Blockly.serialization.blocks.State,\n      workspace,\n      {recordUndo: false},\n    );\n\n    if (this.type === 'procedures_defreturn') {\n      containerBlock.setFieldValue(this.hasStatements_, 'STATEMENTS');\n    } else {\n      containerBlock.removeInput('STATEMENT_INPUT');\n    }\n\n    return containerBlock;\n  },\n\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   *\n   * @param containerBlock Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  compose: function (containerBlock) {\n    // Note that only one of these four things can actually occur for any given\n    // composition, because the user can only drag blocks around so quickly.\n    // So we can use that when making assumptions inside the definitions of\n    // these sub procedures.\n    this.deleteParamsFromModel_(containerBlock);\n    this.renameParamsInModel_(containerBlock);\n    this.addParamsToModel_(containerBlock);\n\n    const hasStatements = containerBlock.getFieldValue('STATEMENTS');\n    if (hasStatements !== null) {\n      this.setStatements_(hasStatements === 'TRUE');\n    }\n  },\n\n  /**\n   * Deletes any parameters from the procedure model that do not have associated\n   * parameter blocks in the mutator.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  deleteParamsFromModel_: function (containerBlock) {\n    const ids = new Set(containerBlock.getDescendants().map((b) => b.id));\n    const model = this.getProcedureModel();\n    const count = model.getParameters().length;\n    for (let i = count - 1; i >= 0; i--) {\n      if (!ids.has(model.getParameter(i).getId())) {\n        model.deleteParameter(i);\n      }\n    }\n  },\n\n  /**\n   * Renames any parameters in the procedure model whose associated parameter\n   * blocks have been renamed.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  renameParamsInModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      const param = model.getParameter(i);\n      if (\n        param &&\n        param.getId() === paramBlock.id &&\n        param.getName() !== paramBlock.getFieldValue('NAME')\n      ) {\n        param.setName(paramBlock.getFieldValue('NAME'));\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n\n  /**\n   * Adds new parameters to the procedure model for any new procedure parameter\n   * blocks.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  addParamsToModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      if (\n        !model.getParameter(i) ||\n        model.getParameter(i).getId() !== paramBlock.id\n      ) {\n        model.insertParameter(\n          new ObservableParameterModel(\n            this.workspace,\n            paramBlock.getFieldValue('NAME'),\n            paramBlock.id,\n          ),\n          i,\n        );\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_def_mutator',\n  procedureDefMutator,\n  undefined,\n  ['procedures_mutatorarg'],\n);\n\nconst procedureDefContextMenuMixin = {\n  /**\n   * Add custom menu options to this block's context menu.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (\n    options: Array<\n      | Blockly.ContextMenuRegistry.ContextMenuOption\n      | Blockly.ContextMenuRegistry.LegacyContextMenuOption\n    >,\n  ) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    const xmlMutation = Blockly.utils.xml.createElement('mutation');\n    xmlMutation.setAttribute('name', this.getFieldValue('NAME'));\n    const params = this.getProcedureModel().getParameters();\n    for (const param of params) {\n      const xmlArg = Blockly.utils.xml.createElement('arg');\n      xmlArg.setAttribute('name', param.getName());\n      xmlMutation.appendChild(xmlArg);\n    }\n    const xmlBlock = Blockly.utils.xml.createElement('block');\n    xmlBlock.setAttribute('type', this.callType_);\n    xmlBlock.appendChild(xmlMutation);\n\n    // Add option to create caller.\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_CREATE_DO'].replace(\n        '%1',\n        this.getFieldValue('NAME'),\n      ),\n      callback: Blockly.ContextMenu.callbackFactory(\n        this,\n        xmlBlock,\n      ) as () => void,\n    });\n\n    // Add options to create getters for each parameter.\n    if (this.isCollapsed()) return;\n\n    for (const param of params) {\n      const argVar = param.getVariableModel();\n      const argXmlField = Blockly.Variables.generateVariableFieldDom(argVar);\n      const argXmlBlock = Blockly.utils.xml.createElement('block');\n      argXmlBlock.setAttribute('type', 'variables_get');\n      argXmlBlock.appendChild(argXmlField);\n      options.push({\n        enabled: true,\n        text: Blockly.Msg['VARIABLES_SET_CREATE_GET'].replace(\n          '%1',\n          argVar.name,\n        ),\n        callback: Blockly.ContextMenu.callbackFactory(\n          this,\n          argXmlBlock,\n        ) as () => void,\n      });\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_context_menu_mixin',\n  procedureDefContextMenuMixin,\n);\n\nconst procedureDefOnChangeMixin = {\n  onchange: function (e) {\n    if (e.type === Blockly.Events.BLOCK_CREATE && e.blockId === this.id) {\n      Blockly.Events.fire(\n        new ProcedureCreate(this.workspace, this.getProcedureModel()),\n      );\n    }\n    if (\n      e.type === Blockly.Events.BLOCK_CHANGE &&\n      e.blockId === this.id &&\n      e.element === 'disabled'\n    ) {\n      this.getProcedureModel().setEnabled(!e.newValue);\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_onchange_mixin',\n  procedureDefOnChangeMixin,\n);\n\nconst procedureDefNoReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defnoreturn_set_comment_helper',\n  procedureDefNoReturnSetCommentHelper,\n);\n\nconst procedureDefReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defreturn_set_comment_helper',\n  procedureDefReturnSetCommentHelper,\n);\n\nconst procedureDefNoReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defnoreturn_get_caller_block_mixin',\n  procedureDefNoReturnGetCallerBlockMixin,\n);\n\nconst procedureDefReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defreturn_get_caller_block_mixin',\n  procedureDefReturnGetCallerBlockMixin,\n);\n\nconst procedureDefSetNoReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes(null);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_no_return_helper',\n  procedureDefSetNoReturnHelper,\n);\n\nconst procedureDefSetReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes([]);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_return_helper',\n  procedureDefSetReturnHelper,\n);\n\nconst procedureCallerGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    prevParams_: [],\n\n    argsMap_: new Map(),\n\n    /**\n     * Returns the procedure model associated with this block.\n     *\n     * @returns The procedure model associated with this block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * Returns the procedure model tha was found.\n     *\n     * @param name The name of the procedure model to find.\n     * @param params The param names of the procedure model\n     *     to find.\n     * @returns The procedure model that was found.\n     */\n    findProcedureModel_(name, params = []) {\n      const workspace = this.getTargetWorkspace_();\n      const model = workspace\n        .getProcedureMap()\n        .getProcedures()\n        .find((proc) => proc.getName() === name);\n      if (!model) return null;\n\n      const returnTypes = model.getReturnTypes();\n      const hasMatchingReturn = this.hasReturn_ ? returnTypes : !returnTypes;\n      if (!hasMatchingReturn) return null;\n\n      const hasMatchingParams = model\n        .getParameters()\n        .every((p, i) => p.getName() === params[i]);\n      if (!hasMatchingParams) return null;\n\n      return model;\n    },\n\n    /**\n     * Returns the main workspace (i.e. not the flyout workspace) associated\n     * with this block.\n     *\n     * @returns The main workspace (i.e. not the flyout workspace) associated\n     *     with this block.\n     */\n    getTargetWorkspace_() {\n      return this.workspace.isFlyout\n        ? this.workspace.targetWorkspace\n        : this.workspace;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns False because this is not a procedure definition block.\n     */\n    isProcedureDef() {\n      return false;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_get_def_mixin',\n  procedureCallerGetDefMixin,\n);\n\nconst procedureCallerVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_var_mixin',\n  procedureCallerVarMixin,\n);\n\nconst procedureCallerMutator = {\n  previousEnabledState_: true,\n\n  paramsFromSerializedState_: [],\n\n  /**\n   * Create XML to represent the (non-editable) name and arguments.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const model = this.getProcedureModel();\n    if (!model) return container;\n\n    container.setAttribute('name', model.getName());\n    for (const param of model.getParameters()) {\n      const arg = Blockly.utils.xml.createElement('arg');\n      arg.setAttribute('name', param.getName());\n      container.appendChild(arg);\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the (non-editable) name and parameters.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const name = xmlElement.getAttribute('name');\n    const params = [];\n    for (const n of xmlElement.childNodes) {\n      if (n.nodeName.toLowerCase() === 'arg') {\n        params.push(n.getAttribute('name'));\n      }\n    }\n    this.deserialize_(name, params);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of\n   *     this block, ie the params and procedure name.\n   */\n  saveExtraState: function () {\n    const state = Object.create(null);\n    const model = this.getProcedureModel();\n    if (!model) {\n      // We reached here because we've deserialized a caller into a workspace\n      // where its model did not already exist (no procedures array in the json,\n      // and deserialized before any definition block), and are reserializing\n      // it before the event delay has elapsed and change listeners have run.\n      // (If they had run, we would have found or created a model).\n      // Just reserialize any deserialized state. Nothing should have happened\n      // in-between to change it.\n      state['name'] = this.getFieldValue('NAME');\n      state['params'] = this.paramsFromSerializedState_;\n      return state;\n    }\n    state['name'] = model.getName();\n    if (model.getParameters().length) {\n      state['params'] = model.getParameters().map((p) => p.getName());\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the params and\n   *     procedure name.\n   */\n  loadExtraState: function (state) {\n    this.deserialize_(state['name'], state['params'] || []);\n  },\n\n  /**\n   * Applies the given name and params from the serialized state to the block.\n   *\n   * @param name The name to apply to the block.\n   * @param params The parameters to apply to the block.\n   */\n  deserialize_: function (name, params) {\n    this.setFieldValue(name, 'NAME');\n    if (!this.model_) this.model_ = this.findProcedureModel_(name, params);\n    if (this.getProcedureModel()) {\n      this.initBlockWithProcedureModel_();\n    } else {\n      // Create inputs based on the mutation so that children can be connected.\n      this.createArgInputs_(params);\n    }\n    this.paramsFromSerializedState_ = params;\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_caller_mutator',\n  procedureCallerMutator,\n);\n\nconst procedureCallerUpdateShapeMixin = {\n  /**\n   * Renders the block for the first time based on the procedure model.\n   */\n  initBlockWithProcedureModel_() {\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n    this.doProcedureUpdate();\n  },\n\n  /**\n   * Updates the shape of this block to reflect the state of the data model.\n   */\n  doProcedureUpdate: function () {\n    if (!this.getProcedureModel()) return;\n    const id = this.getProcedureModel().getId();\n    if (!this.getTargetWorkspace_().getProcedureMap().has(id)) {\n      this.dispose();\n      return;\n    }\n    this.updateName_();\n    this.updateEnabled_();\n    this.updateParameters_();\n  },\n\n  /**\n   * Updates the name field of this block to match the state of the data model.\n   */\n  updateName_: function () {\n    const name = this.getProcedureModel().getName();\n    this.setFieldValue(name, 'NAME');\n    const baseMsg = this.outputConnection\n      ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n      : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n    this.setTooltip(baseMsg.replace('%1', name));\n  },\n\n  /**\n   * Updates the enabled state of this block to match the state of the data\n   *     model.\n   */\n  updateEnabled_: function () {\n    if (!this.getProcedureModel().getEnabled()) {\n      this.previousEnabledState_ = this.isEnabled();\n      this.setEnabled(false);\n    } else {\n      this.setEnabled(this.previousEnabledState_);\n    }\n  },\n\n  /**\n   * Updates the parameter fields/inputs of this block to match the state of the\n   * data model.\n   */\n  updateParameters_: function () {\n    this.syncArgsMap_();\n    this.deleteAllArgInputs_();\n    this.addParametersLabel__();\n    this.createArgInputs_();\n    this.reattachBlocks_();\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n  },\n\n  /**\n   * Makes sure that if we are updating the parameters before any move events\n   * have happened, the args map records the current state of the block. Does\n   * not remove entries from the array, since blocks can be disconnected\n   * temporarily during mutation (which triggers this method).\n   */\n  syncArgsMap_: function () {\n    // We look at the prevParams array because the current state of the block\n    // matches the old params, not the new params state.\n    for (const [i, p] of this.prevParams_.entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) this.argsMap_.set(p.getId(), target);\n    }\n  },\n\n  /**\n   * Saves a map of parameter IDs to target blocks attached to the inputs\n   * of this caller block.\n   */\n  updateArgsMap_: function () {\n    for (const [i, p] of this.getProcedureModel().getParameters().entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) {\n        this.argsMap_.set(p.getId(), target);\n      } else {\n        this.argsMap_.delete(p.getId());\n      }\n    }\n  },\n\n  /**\n   * Deletes all the parameter inputs on this block.\n   */\n  deleteAllArgInputs_: function () {\n    let i = 0;\n    while (this.getInput(`ARG${i}`)) {\n      this.removeInput(`ARG${i}`);\n      i++;\n    }\n  },\n\n  /**\n   * Adds or removes the parameter label to match the state of the data model.\n   */\n  addParametersLabel__: function () {\n    const topRow = this.getInput('TOPROW');\n    if (this.getProcedureModel().getParameters().length) {\n      if (!this.getField('WITH')) {\n        topRow.appendField(\n          Blockly.Msg['PROCEDURES_CALL_BEFORE_PARAMS'],\n          'WITH',\n        );\n        topRow.init();\n      }\n    } else if (this.getField('WITH')) {\n      topRow.removeField('WITH');\n    }\n  },\n\n  /**\n   * Creates all of the parameter inputs to match the state of the data model.\n   *\n   * @param params The params to add to the block, or null to\n   *     use the params defined in the procedure model.\n   */\n  createArgInputs_: function (params = null) {\n    if (!params) {\n      params = this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getName());\n    }\n    for (const [i, p] of params.entries()) {\n      this.appendValueInput(`ARG${i}`)\n        .appendField(new Blockly.FieldLabel(p), `ARGNAME${i}`)\n        .setAlign(Blockly.Input.Align.RIGHT);\n    }\n  },\n\n  /**\n   * Reattaches blocks to this blocks' inputs based on the data saved in the\n   * argsMap_.\n   */\n  reattachBlocks_: function () {\n    const params = this.getProcedureModel().getParameters();\n    for (const [i, p] of params.entries()) {\n      if (!this.argsMap_.has(p.getId())) continue;\n      this.getInput(`ARG${i}`).connection.connect(\n        this.argsMap_.get(p.getId()).outputConnection,\n      );\n    }\n  },\n\n  /**\n   * Notification that a procedure is renaming.\n   * If the name matches this block's procedure, rename it.\n   *\n   * @param oldName Previous name of procedure.\n   * @param newName Renamed procedure.\n   * @this {Blockly.Block}\n   */\n  renameProcedure: function (oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('NAME'))) {\n      this.setFieldValue(newName, 'NAME');\n      const baseMsg = this.outputConnection\n        ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n        : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n      this.setTooltip(baseMsg.replace('%1', newName));\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_update_shape_mixin',\n  procedureCallerUpdateShapeMixin,\n);\n\nconst procedureCallerOnChangeMixin = {\n  /**\n   * Procedure calls cannot exist without the corresponding procedure\n   * definition.  Enforce this link whenever an event is fired.\n   *\n   * @param event Change event.\n   * @this {Blockly.Block}\n   */\n  onchange: function (event) {\n    if (this.disposed || this.workspace.isFlyout) return;\n    if (event.type === Blockly.Events.BLOCK_MOVE) this.updateArgsMap_(true);\n    if (\n      event.type !== Blockly.Events.FINISHED_LOADING &&\n      !this.eventIsCreatingThisBlockDuringPaste_(event)\n    )\n      return;\n\n    // We already found our model, which means we don't need to create a block.\n    if (this.getProcedureModel()) return;\n\n    // Look for the case where a procedure call was created (usually through\n    // paste) and there is no matching definition.  In this case, create\n    // an empty definition block with the correct signature.\n    const name = this.getFieldValue('NAME');\n    let def = Blockly.Procedures.getDefinition(name, this.workspace);\n    if (!this.defMatches_(def)) def = null;\n    if (!def) {\n      // We have no def nor procedure model.\n      Blockly.Events.setGroup(event.group);\n      this.model_ = this.createDef_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n      Blockly.Events.setGroup(false);\n    }\n    if (!this.getProcedureModel()) {\n      // We have a def, but no reference to its model.\n      this.model_ = this.findProcedureModel_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n    }\n    this.initBlockWithProcedureModel_();\n  },\n\n  /**\n   * @param event The event to check.\n   * @returns True if the given event is a paste event for this block.\n   */\n  eventIsCreatingThisBlockDuringPaste_(event) {\n    return (\n      event.type === Blockly.Events.BLOCK_CREATE &&\n      (event.blockId === this.id || event.ids.indexOf(this.id) !== -1) &&\n      // Record undo makes sure this is during paste.\n      event.recordUndo\n    );\n  },\n\n  /**\n   * Returns true if the given def block matches the definition of this caller\n   * block.\n   *\n   * @param defBlock The definition block to check against.\n   * @returns Whether the def block matches or not.\n   */\n  defMatches_(defBlock) {\n    return (\n      defBlock &&\n      defBlock.type === this.defType_ &&\n      JSON.stringify(defBlock.getVars()) ===\n        JSON.stringify(this.paramsFromSerializedState_)\n    );\n  },\n\n  /**\n   * Creates a procedure definition block with the given name and params,\n   * and returns the procedure model associated with it.\n   *\n   * @param name The name of the procedure to create.\n   * @param params The names of the parameters to create.\n   * @returns The procedure model associated with the new\n   *     procedure definition block.\n   */\n  createDef_(name, params = []) {\n    const xy = this.getRelativeToSurfaceXY();\n    const newName = Blockly.Procedures.findLegalName(name, this);\n    this.renameProcedure(name, newName);\n\n    const blockDef = {\n      type: this.defType_,\n      x: xy.x + Blockly.config.snapRadius * (this.RTL ? -1 : 1),\n      y: xy.y + Blockly.config.snapRadius * 2,\n      extraState: {\n        params: params.map((p) => ({name: p})),\n      },\n      fields: {NAME: newName},\n    };\n    const block = Blockly.serialization.blocks.append(\n      blockDef,\n      this.getTargetWorkspace_(),\n      {recordUndo: true},\n    );\n    return (block as unknown as IProcedureBlock).getProcedureModel();\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_onchange_mixin',\n  procedureCallerOnChangeMixin,\n);\n\nconst procedureCallerContextMenuMixin = {\n  /**\n   * Add menu option to find the definition block for this call.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (options) {\n    if (!this.workspace.isMovable()) {\n      // If we center on the block and the workspace isn't movable we could\n      // lose blocks at the edges of the workspace.\n      return;\n    }\n\n    const name = this.getFieldValue('NAME');\n    const workspace = this.workspace;\n    const callback = function () {\n      const def = Blockly.Procedures.getDefinition(name, workspace);\n      if (def && def instanceof Blockly.BlockSvg) {\n        workspace.centerOnBlock(def.id);\n        def.select();\n      }\n    };\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_HIGHLIGHT_DEF'],\n      callback: callback,\n    });\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_context_menu_mixin',\n  procedureCallerContextMenuMixin,\n);\n\nconst procedureCallerNoReturnGetDefBlockMixin = {\n  hasReturn_: false,\n  defType_: 'procedures_defnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callernoreturn_get_def_block_mixin',\n  procedureCallerNoReturnGetDefBlockMixin,\n);\n\nconst procedureCallerReturnGetDefBlockMixin = {\n  hasReturn_: true,\n  defType_: 'procedures_defreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callerreturn_get_def_block_mixin',\n  procedureCallerReturnGetDefBlockMixin,\n);\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/** The interface for a block which models a procedure. */\nexport interface IProcedureBlock {\n  getProcedureModel(): Blockly.procedures.IProcedureModel;\n  doProcedureUpdate(): void;\n  isProcedureDef(): boolean;\n}\n\n/**\n * A type guard which checks if the given block is a procedure block.\n *\n * @param block The block to check for procedure-y-ness.\n * @returns Whether this block is a procedure block or not.\n */\nexport function isProcedureBlock(\n  block: Blockly.Block | IProcedureBlock,\n): block is IProcedureBlock {\n  return (\n    (block as IProcedureBlock).getProcedureModel !== undefined &&\n    (block as IProcedureBlock).doProcedureUpdate !== undefined &&\n    (block as IProcedureBlock).isProcedureDef !== undefined\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\nexport {blocks} from './blocks';\nexport {IProcedureBlock, isProcedureBlock} from './i_procedure_block';\nexport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nexport {\n  ProcedureChangeReturn,\n  ProcedureChangeReturnJson,\n} from './events_procedure_change_return';\nexport {ProcedureCreate, ProcedureCreateJson} from './events_procedure_create';\nexport {ProcedureDelete, ProcedureDeleteJson} from './events_procedure_delete';\nexport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nexport {\n  ProcedureParameterCreate,\n  ProcedureParameterCreateJson,\n} from './events_procedure_parameter_create';\nexport {\n  ProcedureParameterDelete,\n  ProcedureParameterDeleteJson,\n} from './events_procedure_parameter_delete';\nexport {\n  ProcedureParameterRename,\n  ProcedureParameterRenameJson,\n} from './events_procedure_parameter_rename';\nexport {ProcedureRename, ProcedureRenameJson} from './events_procedure_rename';\nexport {triggerProceduresUpdate} from './update_procedures';\n\nexport {ObservableParameterModel, ObservableProcedureModel};\n\n/**\n * Unregisters all of the procedure blocks.\n *\n * Usually used to unregister the built-in blocks, before register the\n * blocks provided by this plugin.\n */\nexport function unregisterProcedureBlocks() {\n  delete Blockly.Blocks['procedures_defnoreturn'];\n  delete Blockly.Blocks['procedures_callnoreturn'];\n  delete Blockly.Blocks['procedures_defreturn'];\n  delete Blockly.Blocks['procedures_callreturn'];\n}\n\n/**\n * Unregisters any existing procedure serializer, and registers a new one\n * parameterized with the shareable procedure backing data models.\n */\nexport function registerProcedureSerializer() {\n  Blockly.serialization.registry.unregister('procedures');\n  Blockly.serialization.registry.register(\n    'procedures',\n    new Blockly.serialization.procedures.ProcedureSerializer(\n      ObservableProcedureModel,\n      ObservableParameterModel,\n    ),\n  );\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ProcedureBase","constructor","workspace","procedure","super","type","TYPE","isBlank","workspaceId","id","toJson","json","getId","ProcedureParameterBase","parameter","recordUndo","static","procedureId","paramId","getProcedureMap","getParameters","find","p","ProcedureParameterRename","oldName","newName","newVarId","getName","getVariableModel","run","forward","findMatchingParameter","getEventWorkspace_","setName","Error","triggerProceduresUpdate","isClearing","block","getAllBlocks","doProcedureUpdate","ObservableParameterModel","name","varId","shouldFireEvents","procedureModel","variable","createBackingVariable","getVariable","createVariable","setTypes","types","getTypes","startPublishing","stopPublishing","setProcedureModel","model","ProcedureChangeReturn","workpace","oldTypes","newTypes","getReturnTypes","setReturnTypes","ProcedureCreate","procedureMap","add","delete","ObservableProcedureModel","ProcedureDelete","ProcedureEnable","newState","oldState","getEnabled","setEnabled","ProcedureParameterCreate","index","insertParameter","deleteParameter","ProcedureParameterDelete","ProcedureRename","parameters","returnTypes","enabled","shouldTriggerUpdates","parameterModel","splice","oldParam","length","oldReturnTypes","startBulkUpdate","endBulkUpdate","getParameter","param","blocks","message0","message1","args0","text","spellcheck","args1","style","helpUrl","tooltip","extensions","mutator","nextStatement","previousStatement","message2","args2","align","output","mixin","model_","getProcedureModel","isProcedureDef","getVars","map","getVarModels","destroy","getFieldValue","renameVarById","oldId","newId","oldVar","getVariableById","findIndex","newVar","updateVarName","some","procedureDefUpdateShapeMixin","setFieldValue","updateParameters_","updateMutator_","params","paramString","join","getIcon","bubbleIsVisible","mutatorWorkspace","getWorkspace","getBlockById","setStatements_","hasStatements","hasStatements_","appendStatementInput","appendField","getInput","moveInputBefore","statementConnection_","stackConnection","connection","targetConnection","stackBlock","targetBlock","unplug","bumpNeighbours","removeInput","nameField","getField","setValue","setValidator","procedureDefMutator","mutationToDom","container","varModel","setAttribute","appendChild","domToMutation","xmlElement","childNodes","node","nodeName","toLowerCase","getAttribute","saveExtraState","doFullSerialization","state","create","loadExtraState","has","newParams","newIds","Set","currParams","decompose","containerBlockDef","inputs","STACK","connDef","fields","NAME","next","containerBlock","compose","deleteParamsFromModel_","renameParamsInModel_","addParamsToModel_","ids","getDescendants","b","paramBlock","getInputTargetBlock","isInsertionMarker","nextConnection","procedureDefContextMenuMixin","customContextMenu","options","isInFlyout","xmlMutation","xmlArg","xmlBlock","callType_","push","callback","isCollapsed","argVar","argXmlField","argXmlBlock","procedureDefOnChangeMixin","onchange","e","blockId","element","newValue","comments","parentWorkspace","setCommentText","prevParams_","argsMap_","Map","findProcedureModel_","getTargetWorkspace_","getProcedures","proc","hasReturn_","every","isFlyout","targetWorkspace","procedureCallerMutator","previousEnabledState_","paramsFromSerializedState_","arg","n","deserialize_","initBlockWithProcedureModel_","createArgInputs_","procedureCallerUpdateShapeMixin","updateName_","updateEnabled_","dispose","baseMsg","outputConnection","setTooltip","replace","isEnabled","syncArgsMap_","deleteAllArgInputs_","addParametersLabel__","reattachBlocks_","entries","target","set","updateArgsMap_","topRow","init","removeField","appendValueInput","setAlign","connect","renameProcedure","procedureCallerOnChangeMixin","event","disposed","eventIsCreatingThisBlockDuringPaste_","def","defMatches_","group","createDef_","indexOf","defBlock","defType_","JSON","stringify","xy","getRelativeToSurfaceXY","blockDef","x","RTL","y","extraState","procedureCallerContextMenuMixin","isMovable","centerOnBlock","select","isProcedureBlock","unregisterProcedureBlocks","registerProcedureSerializer"],"sourceRoot":""}
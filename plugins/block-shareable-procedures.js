import * as Blockly from "blockly";
import {
    unregisterProcedureBlocks,
    registerProcedureSerializer,
    ProcedureBase,
    blocks
} from "@blockly/block-shareable-procedures";
import {options, toolbox} from "../toolbox";
import {javascriptGenerator} from "blockly/javascript.js";
import {createNewVariable, oopVariablesFlyoutCallback} from "../custom_categories/oop_variables.js";
import {
    blockChanged,
    oopDynMethodsFlyoutCallback
} from "../custom_automation/oop_method_automation.js";

// Initialize plugin block-shareable-procedures (deletes vanilla procedure-blocks and registers procedure-blocks of the plugin).
unregisterProcedureBlocks();
Blockly.common.defineBlocks(blocks);
registerProcedureSerializer();

// All the workspaces.
export let workspaces = [];
let categories = {};

/**
 * Injects a new Blockly workspace into the given div container.
 *
 * @param name Name of the new class
 */
export function generateWorkspace(name) {
    // Inject Blockly workspace into given div container.
    workspaces.push(Blockly.inject("blockly" + name, options));
    let currentworkspace = workspaces[workspaces.length - 1]
    currentworkspace.MAX_UNDO = 0;

    for (let i = 0; i < workspaces.length - 1; i++) {
        currentworkspace.addChangeListener(createEventSharer(workspaces[i]));
        workspaces[i].addChangeListener(createEventSharer(currentworkspace));
    }

    currentworkspace.addChangeListener(function (event) {
        if (event.type === Blockly.Events.BLOCK_CHANGE) {
            //console.log('Block changed in workspace:', name, event.toJson());
            blockChanged(event.toJson(), currentworkspace);
        }
    });

    // Register custom category Variables.
    currentworkspace.registerToolboxCategoryCallback("OOP_VARIABLES", oopVariablesFlyoutCallback);
    currentworkspace.registerButtonCallback("createNewVariable", createNewVariable);

    const newCategory = {
        "kind": "category",
        "name": name,
        "custom": "OOP_DYN_" + name,
        "colour": 210,
        "contents": [
        ],
    }
    categories[name] = currentworkspace.id;
    addCategory(newCategory);
}

export function updateToolbox() {
    for (let i = 0; i < workspaces.length; i++) {
        workspaces[i].updateToolbox(toolbox);
    }
}

function addCategory(newCategory) {
    toolbox.contents.push(newCategory);
    for (let i = 0; i < workspaces.length; i++) {
        for(const key in categories) {
            workspaces[i].registerToolboxCategoryCallback("OOP_DYN_" + key, (ws) => oopDynMethodsFlyoutCallback(ws, categories[key]));
        }
    }
}

export function renameCategory(oldName, newName) {
    const newCategory = {
        "kind": "category",
        "name": newName,
        "custom": "OOP_DYN_" + newName,
        "colour": 210,
        "contents": [
        ],
    }
    categories[newName] = workspaces[workspaces.length - 1].id
    addCategory(newCategory)
    removeCategory(oldName)
}

export function removeCategory(name) {
    const index = toolbox.contents.findIndex(category => category.name === name);
    toolbox.contents.splice(index, 1);
    delete categories[name];
}

/**
 * Returns an event listener that shares procedure and var events from the connected workspace to the other workspace.
 *
 * @param {!Blockly.Workspace} otherWorkspace The workspace to share events to.
 * @returns {function(Blockly.Events.Abstract)} The listener.
 */
function createEventSharer(otherWorkspace) {
    return (e) => {
        if (!(e instanceof ProcedureBase) && !(e instanceof Blockly.Events.VarBase)) {
            return;
        }
        let event;
        try {
            event = Blockly.Events.fromJson(e.toJson(), otherWorkspace);
        } catch (e) {
            // Could not deserialize event.  This is expected to happen.
            return;
        }
        event.run(true);
    };
}

/**
 * Generates the code of the Blockly workspaces and shows it in the console of the browser.
 */
export function showCode() {
    let code = "";

    for (let i = 1; i < workspaces.length; i++) {
        code += javascriptGenerator.workspaceToCode(workspaces[i]) + "\n\n";
    }
    code += javascriptGenerator.workspaceToCode(workspaces[0]);
    console.log(code);
    return code;
}

/**
 * Execute the code generated by Blockly.
 */
export function runCode() {
    const code = showCode();
    const initFunc = function (interpreter, globalObject) {
        interpreter.setProperty(globalObject, 'url', String(location));

        const wrapper = function alert(text) {
            return window.alert(text);
        };
        interpreter.setProperty(globalObject, 'alert', interpreter.createNativeFunction(wrapper));
    };
    const codeInterpreter = new Interpreter(code, initFunc);
    codeInterpreter.run();
}